Script started on Fri 29 Apr 2016 02:25:58 AM CDT
bash-4.3$ sh Procedure.sh

whoami|name

No arguments, operating as filter
Userid    Name                          Home Dir
ponnaga   PONNAGANTI GAUTHAM B          /home/ponnaga 
Found 1 matches

ls -ltr

total 156
-rw-r--r-- 1 ponnaga ponnaga  1497 Apr 25 11:05 PCB.java
-rw-r--r-- 1 ponnaga ponnaga 17885 Apr 29 00:34 Loader.java
-rw-r--r-- 1 ponnaga ponnaga 65580 Apr 29 00:34 CPU.java
-rw-r--r-- 1 ponnaga ponnaga  1811 Apr 29 00:34 Disk.java
-rw-r--r-- 1 ponnaga ponnaga  5817 Apr 29 00:34 ErrorHandler.java
-rw-r--r-- 1 ponnaga ponnaga  3710 Apr 29 00:34 Memory.java
-rw-r--r-- 1 ponnaga ponnaga 24177 Apr 29 00:36 Scheduler.java
-rw-r--r-- 1 ponnaga ponnaga  3894 Apr 29 01:27 SWE_report.txt
-rw------- 1 ponnaga ponnaga  4750 Apr 29 02:20 Procedure.sh
-rw------- 1 ponnaga ponnaga   607 Apr 29 02:22 MLFBQ.txt
-rw-r--r-- 1 ponnaga ponnaga  3303 Apr 29 02:24 system.java
-rw------- 1 ponnaga ponnaga     0 Apr 29 02:25 typescript

javac *.java


ls -ltr

total 252
-rw-r--r-- 1 ponnaga ponnaga  1497 Apr 25 11:05 PCB.java
-rw-r--r-- 1 ponnaga ponnaga 17885 Apr 29 00:34 Loader.java
-rw-r--r-- 1 ponnaga ponnaga 65580 Apr 29 00:34 CPU.java
-rw-r--r-- 1 ponnaga ponnaga  1811 Apr 29 00:34 Disk.java
-rw-r--r-- 1 ponnaga ponnaga  5817 Apr 29 00:34 ErrorHandler.java
-rw-r--r-- 1 ponnaga ponnaga  3710 Apr 29 00:34 Memory.java
-rw-r--r-- 1 ponnaga ponnaga 24177 Apr 29 00:36 Scheduler.java
-rw-r--r-- 1 ponnaga ponnaga  3894 Apr 29 01:27 SWE_report.txt
-rw------- 1 ponnaga ponnaga  4750 Apr 29 02:20 Procedure.sh
-rw------- 1 ponnaga ponnaga   607 Apr 29 02:22 MLFBQ.txt
-rw-r--r-- 1 ponnaga ponnaga  3303 Apr 29 02:24 system.java
-rw------- 1 ponnaga ponnaga     0 Apr 29 02:25 typescript
-rw------- 1 ponnaga ponnaga  1634 Apr 29 02:26 CPU$opCode.class
-rw------- 1 ponnaga ponnaga 32384 Apr 29 02:26 CPU.class
-rw------- 1 ponnaga ponnaga  1262 Apr 29 02:26 CPU$1.class
-rw------- 1 ponnaga ponnaga 13992 Apr 29 02:26 Scheduler.class
-rw------- 1 ponnaga ponnaga  1322 Apr 29 02:26 PCB.class
-rw------- 1 ponnaga ponnaga  2357 Apr 29 02:26 Memory.class
-rw------- 1 ponnaga ponnaga  4410 Apr 29 02:26 ErrorHandler.class
-rw------- 1 ponnaga ponnaga  1596 Apr 29 02:26 Disk.class
-rw------- 1 ponnaga ponnaga  3250 Apr 29 02:26 ArthematicOperations.class
-rw------- 1 ponnaga ponnaga  3002 Apr 29 02:26 system.class
-rw------- 1 ponnaga ponnaga 10323 Apr 29 02:26 Loader.class

pr -n *.java



2016-04-29 00:34                     CPU.java                     Page 1


    1	
    2	/*Name: Gautham Brahma Ponnaganti.
    3	 *Course No.: CS5323
    4	 *Assignment title:OS Project PHASE III
    5	 *Date:4-28-2016
    6	 *Global Variables:
    7	 *-errorHandler: this is used to invoke the error handler module.
    8	 *-Memory: This is used to get a reference of memory object. 
    9	 *-IO Handler: This is used for IO operations when we have a RD or a WR operation.
   10	 *-OneClockCycleInTime: This will specify a quantum unit of time.
   11	 *-clock:This is the clock which will keep track of virtual time units during execution.
   12	 *-executionTime&IO time: This will keep track of the time taken for execution and time taken for IO in virtual time units.
   13	 *-AbeforeExecution: This is used to keep track of the value of Accumulator before execution
   14	 *-ALU:used to invoke arithmetic operations class 
   15	 *-Code: Op code value in hex
   16	 *-OpCode: opcode value in user readable format
   17	 *-indirectAdressing:This is set if we detect an indirect addressing bit
   18	 *-addressOfOperand:used for address of the operand for loading the operand into the accumulator.
   19	 *-instructionRegister: This is used to store the instruction to be executed in binary format.
   20	 *-PC: Program counter.
   21	 *-IndexRegister: Used in effective address calculation in case of indexed addressing.
   22	 *-Accumulator,R1-R11,Target: These are general purpose registers along with the above registers.
   23	 *-GPR:used as a list of general Purpose registers
   24	 *
   25	 *Brief description: This is the CPU subsystem which takes the help of Arithmetic Operation class for all ALU 
   26	 *related operations that happen in the system.
   27	 *
   28	 *Changes In Phase II: Made changes in the RD and WR so that they now write to the disk instead of the screen.
   29	 *
   30	 *Changes In Phase III:Recording additional metrics related to subqueues.
   31	 */
   32	
   33	import java.io.FileWriter;
   34	import java.io.IOException;
   35	import java.math.BigInteger;
   36	import java.util.ArrayList;
   37	import java.util.LinkedList;
   38	
   39	public class CPU {
   40	
   41		ErrorHandler errorHandler = new ErrorHandler();
   42		private Memory memory;
   43		final int OneClockCycleInTime = 1;
   44		int chancesAtCPU = 0;
   45		int clock;
   46		ArrayList<Integer> suspectedInfiniteJobID = new ArrayList<Integer>();
   47		int timeJobEnteredTheSystem = 0, cumulativeTimeByJob = 0, timeout = 0,
   48				pageFaultHandlingTime = 0, timeQuantum = 0, numberOfTurns = 0;
   49		int executionTime = 0, ioTime = 0;
   50		/* This variable will be used when writing to trace file */
   51		String AbeforeExecution = null;
   52		ArthematicOperations ALU = new ArthematicOperations();
   53		String[] nullString = {""};
   54		String Code;
   55		String effectiveAddress = null;
   56		opCode OpCode;







2016-04-29 00:34                     CPU.java                     Page 2


   57		int indirectAdressing;
   58		String addressOfOperand;
   59		Disk disk;
   60		int debugCounter = 0;
   61		public static ArrayList<String> memoryDumpArray = new ArrayList<String>();
   62		boolean ReturnToScheduler = false;
   63		boolean hasMore = false;
   64		LinkedList<PCB> runningPCB = new LinkedList<PCB>();
   65		ArrayList<String> tempArrayList = new ArrayList<String>();
   66		String indexToAdd;
   67		int grossRuntime = 0, grossIOTime = 0, grossExecutionTime = 0,
   68				grossTimeInSystem = 0, grossPFHtime = 0;
   69		int CPUIdleTime = 0, TimeLost = 0, numberOfJobNormal = 0,
   70				numberOfJobsAbnormal = 0;
   71		int timeLostInfiniteSuspect = 0, IDOfjobsConsideredInfinite = 0,
   72				numberOfPageaults = 0;
   73		int PercentgeOccupie = 0, HolesInfo = 0;
   74		int suspectedInputTimeout = 0;
   75		int maxNumberOfJobs = 0;
   76		int currentLevel = 0;
   77		/* Register 0 */
   78		String instructionRegister;
   79		String _instructionReg;
   80		int x = 0;
   81		/* Register 1 */
   82		int PC;
   83		int dataPageToLoad, dataPageOffset;
   84		int diskOutPageToWrite;
   85		int VirtualPC;
   86		/* Register 2 Accumulator */
   87		String Accumulator;
   88		/* Register 3 index register */
   89		String IndexRegister;
   90		/* Register 4 */
   91		String R1;
   92		/* Register 5 */
   93		String R2;
   94		/* Register 6 */
   95		String R3;
   96		/* Register 7 */
   97		String R4;
   98		/* Register 8 */
   99		String R5;
  100		/* Register 9 */
  101		String R6;
  102		/* Register 10 */
  103		String R7;
  104		/* Register 11 */
  105		String R8;
  106		/* Register 12 */
  107		String R9;
  108		/* Register 13 */
  109		String R10;
  110		/* Register 14 */
  111		String R11;
  112		/* Register 15 */







2016-04-29 00:34                     CPU.java                     Page 3


  113		String[] GPR = new String[16];
  114		String Target = "00000000000000000000000000000000";
  115		int previousClockVal = 0;
  116		int previousClockVal2 = 0;
  117		int previousClockVal3 = 0;
  118		int normalTermination = 1;
  119		// public static int TotalNumberOfJobs = 0;
  120		int legitJobTime = 0;
  121		public static int ideleTime = 0;
  122	
  123		public static int loadtracker = 0;
  124	
  125		int maxSubqueue1Size = 0;
  126		int maxSubqueue2Size = 0;
  127		int maxSubqueue3Size = 0;
  128		int maxSubqueue4Size = 0;
  129		float cumulativeSubQueu1size = 0;
  130		float cumulativeSubQueu2size = 0;
  131		float cumulativeSubQueu3size = 0;
  132		float cumulativeSubQueu4size = 0;
  133		int queueCount = 0;
  134	
  135		public enum opCode {
  136		HLT, // halt
  137		LD, // Load
  138		ST, // Store
  139		AD, // Add
  140		SB, // Subtract
  141		MPY, // Multiply
  142		DIV, // Divide
  143		SHL, // Shift left
  144		SHR, // Shift Right
  145		BRM, // Branch on minus
  146		BRP, // Branch on plus
  147		BRZ, // Branch on zero
  148		BRL, // Branch on link
  149		AND, OR, RD, // Read
  150		WR, // Write
  151		DMP// Dump memory
  152		}
  153	
  154		public static boolean lastJob = false;
  155	
  156		/*
  157		 * with setMemoryObject we are passing the reference of the memory so that
  158		 * the Memory address and Memory Buffer registers can use this reference to
  159		 * fetch the instructions from the memory
  160		 */
  161		public void setMemoryObject(Memory _memory) {
  162		this.memory = _memory;
  163		}
  164	
  165		public int getclock() {
  166		return clock;
  167		}
  168	







2016-04-29 00:34                     CPU.java                     Page 4


  169		public boolean cpu(int ProgramCounter, int traceSwitch,
  170				LinkedList<PCB> runningQueue, Disk _disk) {
  171		try {
  172		runningPCB.add(runningQueue.get(0));
  173		ReturnToScheduler = false;
  174		if (runningQueue.getFirst().currentOperation.equals("NEW")) {
  175		timeJobEnteredTheSystem = clock;
  176		cumulativeTimeByJob = 0;
  177		timeQuantum = 0;
  178		currentLevel = 1;
  179		numberOfTurns = 1;
  180		chancesAtCPU = 0;
  181		memoryDumpArray.clear();
  182		} else {
  183		timeJobEnteredTheSystem = runningQueue.getFirst().timeJobEnteredTheSystem;
  184		cumulativeTimeByJob = runningQueue.getFirst().cumilativeTimeUsedByJob;
  185		timeQuantum = 0;
  186		pageFaultHandlingTime = runningQueue.getFirst().pageFaultHandlingTime;
  187		numberOfTurns = runningQueue.getFirst().numberOfTurns;
  188		currentLevel = runningQueue.getFirst().currentSubqueueLevel;
  189		chancesAtCPU = runningQueue.getFirst().numberOfChancesCPU + 1;
  190		restoreStateOfProcess();
  191		}
  192		FileWriter statusWrite = new FileWriter("progressFile.txt", true);
  193		if ((clock - previousClockVal) > 10000) {
  194		previousClockVal = clock;
  195		statusWrite.write("\n");
  196		for (int i = 0; i < runningPCB.getFirst().SystemStatus.size(); i++) {
  197		statusWrite.write(runningPCB.getFirst().SystemStatus.get(i).toString());
  198		statusWrite.write("\n");
  199		}
  200		statusWrite.close();
  201		}
  202		if ((clock - previousClockVal2) > 100) {
  203		previousClockVal2 = clock;
  204		if (Scheduler.subqueue1Size > maxSubqueue1Size) {
  205		maxSubqueue1Size = Scheduler.subqueue1Size;
  206		}
  207		if (Scheduler.subqueue2Size > maxSubqueue2Size) {
  208		maxSubqueue2Size = Scheduler.subqueue2Size;
  209		}
  210		if (Scheduler.subqueue3Size > maxSubqueue3Size) {
  211		maxSubqueue3Size = Scheduler.subqueue3Size;
  212		}
  213		if (Scheduler.subqueue4Size > maxSubqueue4Size) {
  214		maxSubqueue4Size = Scheduler.subqueue4Size;
  215		}
  216		cumulativeSubQueu1size += Scheduler.subqueue1Size;
  217		cumulativeSubQueu2size += Scheduler.subqueue2Size;
  218		cumulativeSubQueu3size += Scheduler.subqueue3Size;
  219		cumulativeSubQueu4size += Scheduler.subqueue4Size;
  220		queueCount += 1;
  221		}
  222		if ((clock - previousClockVal3) > 1200) {
  223		previousClockVal3 = clock;
  224		String filename = "MLFBQ.txt";







2016-04-29 00:34                     CPU.java                     Page 5


  225		FileWriter fw5 = new FileWriter(filename, true);
  226		fw5.write(String.format("%-25s %-10s", "Clock value(Hex):", clock));
  227		fw5.write("\n");
  228		if (!Scheduler.contentOfSubqueue1.isEmpty()) {
  229		for (int k = 0; k < Scheduler.contentOfSubqueue1.size(); k++) {
  230		tempArrayList.add(Scheduler.contentOfSubqueue1.get(k).toString());
  231		// fw5.write(Scheduler.contentOfSubqueue1.get(k).toString());
  232		}
  233		fw5.write(String.format("%-25s %-10s", "Contents of subqueue1(DEC):",
  234				tempArrayList));
  235		} else {
  236		fw5.write(String.format("%-25s %-10s", "Contents of subqueue1(DEC):",
  237				"Empty"));
  238		}
  239		fw5.write("\n");
  240		tempArrayList.clear();
  241		if (!Scheduler.contentOfSubqueue2.isEmpty()) {
  242		for (int k = 0; k < Scheduler.contentOfSubqueue2.size(); k++) {
  243		// fw5.write(Scheduler.contentOfSubqueue2.get(k).toString());
  244		tempArrayList.add(Scheduler.contentOfSubqueue2.get(k).toString());
  245		}
  246		fw5.write(String.format("%-25s %-10s", "Contents of subqueue2(DEC):",
  247				tempArrayList));
  248		} else {
  249		fw5.write(String.format("%-25s %-10s", "Contents of subqueue2(DEC):",
  250				"Empty"));
  251		}
  252		fw5.write("\n");
  253		tempArrayList.clear();
  254		if (!Scheduler.contentOfSubqueue3.isEmpty()) {
  255		for (int k = 0; k < Scheduler.contentOfSubqueue3.size(); k++) {
  256		// fw5.write(Scheduler.contentOfSubqueue3.get(k).toString());
  257		tempArrayList.add(Scheduler.contentOfSubqueue3.get(k).toString());
  258		}
  259		fw5.write(String.format("%-25s %-10s", "Contents of subqueue3(DEC):",
  260				tempArrayList));
  261		} else {
  262		fw5.write(String.format("%-25s %-10s", "Contents of subqueue3(DEC):",
  263				"Empty"));
  264		}
  265		fw5.write("\n");
  266		tempArrayList.clear();
  267		if (!Scheduler.contentOfSubqueue4.isEmpty()) {
  268		for (int k = 0; k < Scheduler.contentOfSubqueue4.size(); k++) {
  269		// fw5.write(Scheduler.contentOfSubqueue4.get(k).toString());
  270		tempArrayList.add(Scheduler.contentOfSubqueue4.get(k).toString());
  271		}
  272		fw5.write(String.format("%-25s %-10s", "Contents of subqueue4(DEC):",
  273				tempArrayList));
  274		} else {
  275		fw5.write(String.format("%-25s %-10s", "Contents of subqueue4(DEC):",
  276				"Empty"));
  277		}
  278		fw5.write("\n");
  279		fw5.write("\n");
  280		tempArrayList.clear();







2016-04-29 00:34                     CPU.java                     Page 6


  281		fw5.close();
  282		}
  283		timeout = 0;
  284		this.disk = _disk;
  285		VirtualPC = ProgramCounter;
  286		boolean stopExecution = false;
  287		while (!stopExecution && !ReturnToScheduler) {
  288		PC = convertVirtualAddressToPhysical(VirtualPC);
  289		if (PC == -1) {
  290		ReturnToScheduler = true;
  291		runningPCB.getFirst().currentOperation = "Error";
  292		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  293		errorHandler.HandleError(ErrorHandler.ADDRESS_OUT_OF_RANGE);
  294		runningPCB.getFirst().errorDescription = "Address Out Of Range";
  295		hasMore = false;
  296		writeOutput("Read");
  297		runningPCB.removeFirst();
  298		TimeLost += cumulativeTimeByJob;
  299		return false;
  300		}
  301		instructionRegister = fetchInstruction(PC);
  302		_instructionReg = instructionRegister;
  303		decodeInstruction();
  304	
  305		if (Integer.parseInt(Code, 16) > 17) {
  306		ReturnToScheduler = true;
  307		runningPCB.getFirst().currentOperation = "Error";
  308		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  309		errorHandler.HandleError(ErrorHandler.INVALID_OPCODE);
  310		runningPCB.getFirst().errorDescription = "Invalid Opcode";
  311		hasMore = false;
  312		writeOutput("Invalid Opcode");
  313		runningPCB.removeFirst();
  314		TimeLost += cumulativeTimeByJob;
  315		return false;
  316		}
  317		AbeforeExecution = GPR[Integer.parseInt(Accumulator, 2)];
  318		stopExecution = executeInstruction();
  319		if (runningPCB.getFirst().traceFlag == 1) {
  320		if (runningQueue.getFirst().startedWritingTrace == false) {
  321		FileWriter fww = new FileWriter("trace-JobID-"
  322				+ Integer.toString(runningQueue.getFirst().jobID) + ".txt");
  323		fww.close();
  324		}
  325		FileWriter fw = new FileWriter("trace-JobID-"
  326				+ Integer.toString(runningQueue.getFirst().jobID) + ".txt", true);
  327		if (runningQueue.getFirst().startedWritingTrace == false) {
  328		runningQueue.getFirst().startedWritingTrace = true;
  329		fw.write(String.format("%4s %15s %15s %15s %15s %n", "PC(DEC)",
  330				"Instruction(HEX)", "A Before(HEX)", "A After(HEX)", "EA(HEX)"));
  331		}
  332		String temp1 = binhex(instructionRegister);
  333		if (temp1 == null || temp1 == "") {
  334		temp1 = "0000000";
  335		}
  336		if (AbeforeExecution == null || AbeforeExecution == "") {







2016-04-29 00:34                     CPU.java                     Page 7


  337		AbeforeExecution = "0";
  338		}
  339		String temp2 = binhex(effectiveAddress);
  340		if (temp2 == null || temp2 == "") {
  341		temp2 = "0000";
  342		}
  343		if (Accumulator == null || Accumulator == "") {
  344		Accumulator = "0";
  345		}
  346		if (GPR[Integer.parseInt(Accumulator, 2)] == null
  347				|| GPR[Integer.parseInt(Accumulator, 2)] == "") {
  348		GPR[Integer.parseInt(Accumulator, 2)] = "0000";
  349		}
  350		fw.write(String.format("%4d %15s %15s %15s %15s %n", PC,
  351				binhex(_instructionReg), binhex(AbeforeExecution),
  352				binhex(GPR[Integer.parseInt(Accumulator, 2)]), temp2));
  353		fw.close();
  354		}
  355		if (PC > 255) {
  356		ReturnToScheduler = true;
  357		runningPCB.getFirst().currentOperation = "Error";
  358		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  359		errorHandler.HandleError(ErrorHandler.ADDRESS_OUT_OF_RANGE);
  360		runningPCB.getFirst().errorDescription = "Address Out Of Range";
  361		hasMore = false;
  362		writeOutput("Read");
  363		runningPCB.removeFirst();
  364		TimeLost += cumulativeTimeByJob;
  365		return false;
  366		}
  367		VirtualPC = VirtualPC + 1;
  368		clock += OneClockCycleInTime;
  369		loadtracker += OneClockCycleInTime;
  370		cumulativeTimeByJob += OneClockCycleInTime;
  371		timeQuantum += OneClockCycleInTime;
  372		grossRuntime += OneClockCycleInTime;
  373		timeout += 1;
  374		if (timeQuantum >= Scheduler.allowedQuantum
  375				&& !(Code.equals("10") || Code.equals("0f") || Code.equals("00"))) {
  376		ReturnToScheduler = true;
  377		runningPCB.getFirst().currentOperation = "TimeOut";
  378		numberOfTurns += 1;
  379		writeCurrentStateToPCB("TimeOut");
  380		hasMore = true;
  381		}
  382		if (cumulativeTimeByJob >= 400000) {
  383		suspectedInputTimeout = cumulativeTimeByJob;
  384		ReturnToScheduler = true;
  385		runningPCB.getFirst().currentOperation = "Error";
  386		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  387		errorHandler.HandleError(ErrorHandler.SUSPECTED_INFINITE_JOB);
  388		runningPCB.getFirst().errorDescription = "Suspected Infinite Job";
  389		suspectedInfiniteJobID.add(runningPCB.getFirst().jobID);
  390		hasMore = false;
  391		writeOutput("Infinite");
  392		if (lastJob == true) {







2016-04-29 00:34                     CPU.java                     Page 8


  393		ideleTime = runningPCB.getFirst().iotime;
  394		writeAggregateResults();
  395		}
  396		runningPCB.removeFirst();
  397		TimeLost += cumulativeTimeByJob;
  398		return false;
  399		}
  400		// writer.close();
  401		}
  402		// writer.flush();
  403		} catch (NumberFormatException e) {
  404		ReturnToScheduler = true;
  405		runningPCB.getFirst().currentOperation = "Error";
  406		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  407		errorHandler.HandleError(ErrorHandler.ILLEGAL_CHAR);
  408		runningPCB.getFirst().errorDescription = "Illegal Character";
  409		hasMore = false;
  410		writeOutput("Illegal Character");
  411		TimeLost += cumulativeTimeByJob;
  412		runningPCB.removeFirst();
  413		return false;
  414		} catch (IOException e) {
  415		ReturnToScheduler = true;
  416		runningPCB.getFirst().currentOperation = "Error";
  417		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  418		errorHandler.HandleError(ErrorHandler.IO_EXCEPTION);
  419		runningPCB.getFirst().errorDescription = "Error";
  420		hasMore = false;
  421		writeOutput("IO");
  422		TimeLost += cumulativeTimeByJob;
  423		runningPCB.removeFirst();
  424		return false;
  425		} catch (NullPointerException e) {
  426		ReturnToScheduler = true;
  427		runningPCB.getFirst().currentOperation = "Error";
  428		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  429		errorHandler.HandleError(ErrorHandler.IO_EXCEPTION);
  430		runningPCB.getFirst().errorDescription = "Error";
  431		hasMore = false;
  432		writeOutput("IO");
  433		TimeLost += cumulativeTimeByJob;
  434		runningPCB.removeFirst();
  435		return false;
  436		}
  437	
  438		runningPCB.removeFirst();
  439		return hasMore;
  440		}
  441	
  442		private int convertVirtualAddressToPhysical(int virtualProgCount) {
  443		int virtualAddressInDecimal = virtualProgCount;
  444		String virtualAddressIndex = String.format("%02X", virtualAddressInDecimal);
  445		/*
  446		 * Page Table being an array is indexed in decimal. The hex value needs to
  447		 * be converted to decimal
  448		 */







2016-04-29 00:34                     CPU.java                     Page 9


  449		String PageTableIndex = virtualAddressIndex.substring(0, 1);
  450		String Offset = virtualAddressIndex.substring(1, 2);
  451		int PageTableIndexDec = Integer.parseInt(PageTableIndex, 16);
  452		/* condition will be true if the page is not in memory */
  453		if (runningPCB.getFirst().pageFaultBits.get(PageTableIndexDec)
  454				.substring(0, 1).equals("0")) {
  455		String pageNumberOnMemtoReplace = "";
  456		String pageNumberOnDisktoReplace;
  457		String pageNumberOnDisktoBring;
  458		int pageIndexToReplace = -1;
  459		boolean isPageClean = true;
  460		cumulativeTimeByJob += 5;
  461		timeQuantum += 5;
  462		pageFaultHandlingTime += 5;
  463		grossRuntime += 5;
  464		grossPFHtime += 5;
  465		/* Victim selection stage 1 not used and clean */
  466		for (int i = 0; i < runningPCB.getFirst().ProgramPagesOnMem.length; i++) {
  467		if (runningPCB.getFirst().pageFaultBits.get(i).substring(0, 1).equals("1")
  468				&& runningPCB.getFirst().pageFaultBits.get(i).substring(1, 2)
  469						.equals("0")
  470				&& runningPCB.getFirst().pageFaultBits.get(i).substring(2, 3)
  471						.equals("0")) {
  472		pageIndexToReplace = i;
  473		}
  474		}
  475		/* Victim selection Stage 2 used but still clean */
  476		if (pageIndexToReplace == -1) {
  477		for (int i = 0; i < runningPCB.getFirst().ProgramPagesOnMem.length; i++) {
  478		if (runningPCB.getFirst().pageFaultBits.get(i).substring(0, 1).equals("1")
  479				&& runningPCB.getFirst().pageFaultBits.get(i).substring(1, 2)
  480						.equals("1")
  481				&& runningPCB.getFirst().pageFaultBits.get(i).substring(2, 3)
  482						.equals("0")) {
  483		pageIndexToReplace = i;
  484		}
  485		}
  486		}
  487		/* Victim selection Stage 3 used and dirty */
  488		if (pageIndexToReplace == -1) {
  489		for (int i = 0; i < runningPCB.getFirst().ProgramPagesOnMem.length; i++) {
  490		if (runningPCB.getFirst().pageFaultBits.get(i).substring(0, 1).equals("1")
  491				&& runningPCB.getFirst().pageFaultBits.get(i).substring(1, 2)
  492						.equals("1")
  493				&& runningPCB.getFirst().pageFaultBits.get(i).substring(2, 3)
  494						.equals("1")) {
  495		pageIndexToReplace = i;
  496		isPageClean = false;
  497		}
  498		}
  499		}
  500		if (pageIndexToReplace == -1) {
  501		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  502		errorHandler.HandleError(ErrorHandler.OUT_OF_BOUNDS);
  503		hasMore = false;
  504		ReturnToScheduler = true;







2016-04-29 00:34                    CPU.java                     Page 10


  505		TimeLost += cumulativeTimeByJob;
  506		return -1;
  507		} else {
  508		try {
  509		/* Page is dirty copy it to disk */
  510		if (isPageClean == false) {
  511		String contentInMemPage = "";
  512		pageNumberOnMemtoReplace = runningPCB
  513				.getFirst().ProgramPagesOnMem[pageIndexToReplace];
  514		pageNumberOnDisktoReplace = runningPCB
  515				.getFirst().ProgramPagesOnDisk[pageIndexToReplace];
  516		for (int i = 0; i < 16; i++) {
  517		contentInMemPage += memory.Mem("READ",
  518				Integer.parseInt(pageNumberOnMemtoReplace) * 16 + i, "");
  519		}
  520		for (int i = (Integer.parseInt(pageNumberOnDisktoReplace)
  521				* 16), j = 0; i < (Integer.parseInt(pageNumberOnDisktoReplace) * 16)
  522						+ 16; i++, j = j + 8) {
  523		disk.disk[i] = contentInMemPage.substring(j, j + 8);
  524		}
  525		runningPCB.getFirst().pageFaultBits.set(pageIndexToReplace,
  526				runningPCB.getFirst().pageFaultBits.get(pageIndexToReplace)
  527						.substring(0, 2) + "0");
  528		}
  529		/* replace the page with the page from disk */
  530		String contentInDisk = "";
  531		pageNumberOnDisktoBring = runningPCB
  532				.getFirst().ProgramPagesOnDisk[PageTableIndexDec];
  533		for (int i = Integer.parseInt(pageNumberOnDisktoBring)
  534				* 16; i < (Integer.parseInt(pageNumberOnDisktoBring) * 16)
  535						+ 16; i++) {
  536		contentInDisk += disk.disk[i];
  537		}
  538		pageNumberOnMemtoReplace = runningPCB
  539				.getFirst().ProgramPagesOnMem[pageIndexToReplace];
  540		for (int i = Integer.parseInt(pageNumberOnMemtoReplace)
  541				* 16, j = 0; i < (Integer.parseInt(pageNumberOnMemtoReplace) * 16)
  542						+ 16; i++, j = j + 8) {
  543		memory.Mem("WRIT", i, contentInDisk.substring(j, j + 8));
  544		}
  545		/* update the bits for the page replaced and fetched */
  546		runningPCB.getFirst().pageFaultBits.set(pageIndexToReplace, "000");
  547		runningPCB.getFirst().pageFaultBits.set(PageTableIndexDec, "100");
  548		runningPCB.getFirst().ProgramPagesOnMem[pageIndexToReplace] = null;
  549		runningPCB
  550				.getFirst().ProgramPagesOnMem[PageTableIndexDec] = pageNumberOnMemtoReplace;
  551		} catch (Exception e) {
  552		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  553		errorHandler.HandleError(ErrorHandler.OUT_OF_BOUNDS);
  554		hasMore = false;
  555		ReturnToScheduler = true;
  556		TimeLost += cumulativeTimeByJob;
  557		return -1;
  558		}
  559		}
  560		}







2016-04-29 00:34                    CPU.java                     Page 11


  561		int FrameNumber = Integer.parseInt(
  562				runningPCB.getFirst().ProgramPagesOnMem[PageTableIndexDec]);
  563		runningPCB.getFirst().pageFaultBits.set(PageTableIndexDec,
  564				"11" + runningPCB.getFirst().pageFaultBits.get(PageTableIndexDec)
  565						.substring(2, 3));
  566		String FrameNumberHex = String.format("%01X", FrameNumber);
  567		String PhysicalAddress = FrameNumberHex + Offset;
  568		return Integer.parseInt(PhysicalAddress, 16);
  569		}
  570	
  571		public String fetchInstruction(int ProgramCounter) {
  572		String instruction = Memory.Mem[ProgramCounter];
  573		return HEXBIN(instruction);
  574		}
  575	
  576		/*
  577		 * decode the 32 bit binary instruction to mine appropriate fields and
  578		 * opcode
  579		 */
  580		public void decodeInstruction() {
  581		if (instructionRegister.length() == 32) {
  582		indirectAdressing = Integer.parseInt(instructionRegister.substring(0, 1));
  583		Code = instructionRegister.substring(1, 8);
  584		Accumulator = instructionRegister.substring(8, 12);
  585		IndexRegister = instructionRegister.substring(12, 16);
  586		addressOfOperand = instructionRegister.substring(16, 32);
  587		Code = fetchOpcode(Code);
  588		OpCode = decodeOpcode(Code);
  589		}
  590		}
  591	
  592		/* calculating effective address and executing instruction */
  593		public boolean executeInstruction() {
  594		try {
  595		boolean returnValue = false;
  596		String virtualEffectiveAddress = "";
  597		/* calculating the effective address */
  598		if (indirectAdressing == 0) {
  599		/* direct addressing */
  600		if (IndexRegister.equals("0000")) {
  601		/* do nothing. The address is already effective address */
  602		/*
  603		 * We will keep a copy of virtual address to use for jump instructions
  604		 */
  605		virtualEffectiveAddress = addressOfOperand;
  606		addressOfOperand = convertAddFromVirtualToReal(addressOfOperand);
  607		effectiveAddress = addressOfOperand;
  608		}
  609		/* direct addressing && index addressing */
  610		else {
  611		/*
  612		 * We will keep a copy of virtual address to use for jump instructions
  613		 */
  614		virtualEffectiveAddress = addressOfOperand;
  615		indexToAdd = GPR[Integer.parseInt(IndexRegister, 2)];
  616		effectiveAddress = addAddresses(indexToAdd, addressOfOperand);







2016-04-29 00:34                    CPU.java                     Page 12


  617		virtualEffectiveAddress = effectiveAddress;
  618		effectiveAddress = convertAddFromVirtualToReal(effectiveAddress);
  619		}
  620		} else {
  621		/* indirect addressing */
  622		if (IndexRegister.equals("0000")) {
  623		/*
  624		 * We will keep a copy of virtual address to use for jump instructions
  625		 */
  626		virtualEffectiveAddress = addressOfOperand;
  627		addressOfOperand = convertAddFromVirtualToReal(addressOfOperand);
  628		try {
  629		effectiveAddress = memory.Mem("READ", Integer.parseInt(addressOfOperand, 2),
  630				R1);
  631		} catch (NumberFormatException e) {
  632		System.out.print("");
  633		}
  634		effectiveAddress = HEXBIN(effectiveAddress);
  635		virtualEffectiveAddress = effectiveAddress;
  636		effectiveAddress = convertAddFromVirtualToReal(effectiveAddress);
  637		}
  638		/* indirect addressing && index addressing */
  639		else {
  640		/*
  641		 * We will keep a copy of virtual address to use for jump instructions
  642		 */
  643		virtualEffectiveAddress = addressOfOperand;
  644		addressOfOperand = convertAddFromVirtualToReal(addressOfOperand);
  645		R2 = memory.Mem("READ", Integer.parseInt(addressOfOperand, 2), R2);
  646		indexToAdd = GPR[Integer.parseInt(IndexRegister, 2)];
  647		virtualEffectiveAddress = addAddresses(HEXBIN(R2), indexToAdd);
  648		effectiveAddress = addAddresses(HEXBIN(R2), indexToAdd);
  649		effectiveAddress = convertAddFromVirtualToReal(effectiveAddress);
  650		}
  651		}
  652		try {
  653		if (Integer.parseInt(effectiveAddress, 2) > 255
  654				|| Integer.parseInt(effectiveAddress, 2) < 0) {
  655		ReturnToScheduler = true;
  656		runningPCB.getFirst().currentOperation = "Error";
  657		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  658		errorHandler.HandleError(ErrorHandler.ADDRESS_OUT_OF_RANGE);
  659		runningPCB.getFirst().errorDescription = "Address Out Of Range";
  660		hasMore = false;
  661		writeOutput("Read");
  662		TimeLost += cumulativeTimeByJob;
  663		return false;
  664		}
  665		} catch (NumberFormatException e) {
  666		ReturnToScheduler = true;
  667		// if(runningPCB.getFirst().jobID==60)
  668		// {
  669		// writeOutput("Halt");
  670		// writeCurrentStateToPCB("Halt");
  671		// runningPCB.getFirst().errorDescription = "Normal Completion";
  672		// hasMore = false;







2016-04-29 00:34                    CPU.java                     Page 13


  673		// writeOutput("halt");
  674		// TimeLost+=cumulativeTimeByJob;
  675		//
  676		// }else{
  677		runningPCB.getFirst().currentOperation = "Error";
  678		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  679		errorHandler.HandleError(ErrorHandler.ARTHEMATIC_ERROR);
  680		runningPCB.getFirst().errorDescription = "Arithematic error.";
  681		hasMore = false;
  682		writeOutput("Arithematic");
  683		TimeLost += cumulativeTimeByJob;
  684		// }
  685		return false;
  686		}
  687	
  688		switch (OpCode) {
  689		case HLT :
  690			normalTermination++;
  691			returnValue = true;
  692			writeOutput("Halt");
  693			writeCurrentStateToPCB("Halt");
  694			runningPCB.getFirst().errorDescription = "Normal Completion";
  695			legitJobTime += runningPCB.getFirst().cumilativeTimeUsedByJob;
  696			if (lastJob == true) {
  697			ideleTime = runningPCB.getFirst().iotime;
  698			writeAggregateResults();
  699			}
  700			break;
  701		case LD :
  702			clock += OneClockCycleInTime;
  703			loadtracker += OneClockCycleInTime;
  704			executionTime += OneClockCycleInTime;
  705			cumulativeTimeByJob += OneClockCycleInTime;
  706			timeQuantum += OneClockCycleInTime;
  707			grossExecutionTime += OneClockCycleInTime;
  708			grossRuntime += OneClockCycleInTime;
  709			timeout += OneClockCycleInTime;
  710			GPR[Integer.parseInt(Accumulator, 2)] = HEXBIN(
  711					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2),
  712							GPR[Integer.parseInt(Accumulator, 2)]));
  713			break;
  714		case ST :
  715			clock += OneClockCycleInTime;
  716			loadtracker += OneClockCycleInTime;
  717			executionTime += OneClockCycleInTime;
  718			cumulativeTimeByJob += OneClockCycleInTime;
  719			timeQuantum += OneClockCycleInTime;
  720			grossExecutionTime += OneClockCycleInTime;
  721			grossRuntime += OneClockCycleInTime;
  722			timeout += OneClockCycleInTime;
  723			GPR[Integer.parseInt(Accumulator, 2)] = HEXBIN(
  724					memory.Mem("WRIT", Integer.parseInt(effectiveAddress, 2),
  725							binhex(GPR[Integer.parseInt(Accumulator, 2)])));
  726	
  727			runningPCB.getFirst().pageFaultBits
  728					.set(Integer.parseInt(virtualEffectiveAddress, 2) / 16, "111");







2016-04-29 00:34                    CPU.java                     Page 14


  729			break;
  730		case AD :
  731			clock += OneClockCycleInTime;
  732			loadtracker += OneClockCycleInTime;
  733			executionTime += OneClockCycleInTime;
  734			cumulativeTimeByJob += OneClockCycleInTime;
  735			timeQuantum += OneClockCycleInTime;
  736			grossExecutionTime += OneClockCycleInTime;
  737			grossRuntime += OneClockCycleInTime;
  738			timeout += OneClockCycleInTime;
  739			R5 = HEXBIN(
  740					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2), R5));
  741			GPR[Integer.parseInt(Accumulator, 2)] = ALU.Add(R5,
  742					GPR[Integer.parseInt(Accumulator, 2)]);
  743			if (GPR[Integer.parseInt(Accumulator, 2)].equals("OVERFLOW")) {
  744			ReturnToScheduler = true;
  745			runningPCB.getFirst().currentOperation = "Error";
  746			ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  747			errorHandler.HandleError(ErrorHandler.INPUT_SIZE_OVERFLOW);
  748			runningPCB.getFirst().errorDescription = "Overflow";
  749			hasMore = false;
  750			writeOutput("Overflow");
  751			TimeLost += cumulativeTimeByJob;
  752			break;
  753			}
  754			break;
  755		case SB :
  756			clock += OneClockCycleInTime;
  757			loadtracker += OneClockCycleInTime;
  758			executionTime += OneClockCycleInTime;
  759			cumulativeTimeByJob += OneClockCycleInTime;
  760			timeQuantum += OneClockCycleInTime;
  761			grossExecutionTime += OneClockCycleInTime;
  762			grossRuntime += OneClockCycleInTime;
  763			timeout += OneClockCycleInTime;
  764			R5 = HEXBIN(
  765					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2), R5));
  766			GPR[Integer.parseInt(Accumulator, 2)] = ALU
  767					.Sub(GPR[Integer.parseInt(Accumulator, 2)], R5);
  768			break;
  769		case MPY :
  770			executionTime += 2 * OneClockCycleInTime;
  771			clock += 2 * OneClockCycleInTime;
  772			loadtracker += 2 * OneClockCycleInTime;
  773			cumulativeTimeByJob += 2 * OneClockCycleInTime;
  774			timeQuantum += 2 * OneClockCycleInTime;
  775			grossExecutionTime += 2 * OneClockCycleInTime;
  776			grossRuntime += 2 * OneClockCycleInTime;
  777			timeout += 2 * OneClockCycleInTime;
  778			R5 = HEXBIN(
  779					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2), R5));
  780			GPR[Integer.parseInt(Accumulator, 2)] = ALU.Mul(R5,
  781					GPR[Integer.parseInt(Accumulator, 2)]);
  782			break;
  783		case DIV :
  784			executionTime += 2 * OneClockCycleInTime;







2016-04-29 00:34                    CPU.java                     Page 15


  785			clock += 2 * OneClockCycleInTime;
  786			loadtracker += 2 * OneClockCycleInTime;
  787			cumulativeTimeByJob += 2 * OneClockCycleInTime;
  788			timeQuantum += 2 * OneClockCycleInTime;
  789			grossExecutionTime += 2 * OneClockCycleInTime;
  790			grossRuntime += 2 * OneClockCycleInTime;
  791			timeout += 2 * OneClockCycleInTime;
  792			R5 = HEXBIN(
  793					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2), R5));
  794			GPR[Integer.parseInt(Accumulator, 2)] = ALU
  795					.Div(GPR[Integer.parseInt(Accumulator, 2)], R5);
  796			if (GPR[Integer.parseInt(Accumulator, 2)].equals("DIVIDEBYZERO")) {
  797			ReturnToScheduler = true;
  798			runningPCB.getFirst().currentOperation = "Error";
  799			ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  800			errorHandler.HandleError(ErrorHandler.DIVIDE_BY_ZERO);
  801			runningPCB.getFirst().errorDescription = "Divide By Zero";
  802			hasMore = false;
  803			writeOutput("Divide by Zero");
  804			TimeLost += cumulativeTimeByJob;
  805			break;
  806			}
  807			break;
  808		case SHL :
  809			executionTime += 1;
  810			cumulativeTimeByJob += OneClockCycleInTime;
  811			timeQuantum += OneClockCycleInTime;
  812			grossRuntime += OneClockCycleInTime;
  813			grossRuntime += OneClockCycleInTime;
  814			grossExecutionTime += 2 * OneClockCycleInTime;
  815			clock += 1;
  816			loadtracker += OneClockCycleInTime;
  817			timeout += 1;
  818			GPR[Integer.parseInt(Accumulator, 2)] = ALU.ShiftLeft(
  819					GPR[Integer.parseInt(Accumulator, 2)], effectiveAddress);
  820			break;
  821		case SHR :
  822			executionTime += 1;
  823			clock += 1;
  824			loadtracker += OneClockCycleInTime;
  825			timeout += 1;
  826			cumulativeTimeByJob += OneClockCycleInTime;
  827			timeQuantum += OneClockCycleInTime;
  828			grossRuntime += OneClockCycleInTime;
  829			grossExecutionTime += 2 * OneClockCycleInTime;
  830			GPR[Integer.parseInt(Accumulator, 2)] = ALU.ShiftRight(
  831					GPR[Integer.parseInt(Accumulator, 2)], effectiveAddress);
  832			break;
  833		case BRM :
  834			executionTime += 1;
  835			cumulativeTimeByJob += OneClockCycleInTime;
  836			timeQuantum += OneClockCycleInTime;
  837			grossRuntime += OneClockCycleInTime;
  838			grossExecutionTime += 2 * OneClockCycleInTime;
  839			clock += 1;
  840			loadtracker += OneClockCycleInTime;







2016-04-29 00:34                    CPU.java                     Page 16


  841			timeout += 1;
  842	
  843			int valueToCompareBRM = Integer.parseInt(
  844					GPR[Integer.parseInt(Accumulator, 2)].substring(1, 32), 2);
  845			int signOfValueToCompareBRM = Integer.parseInt(
  846					GPR[Integer.parseInt(Accumulator, 2)].substring(0, 1));
  847			if (signOfValueToCompareBRM == 1) {
  848			valueToCompareBRM = valueToCompareBRM * -1;
  849			}
  850	
  851			if (valueToCompareBRM < 0) {
  852			VirtualPC = Integer.parseInt(virtualEffectiveAddress, 2) - 1;
  853			}
  854			break;
  855		case BRP :
  856			executionTime += 1;
  857			cumulativeTimeByJob += OneClockCycleInTime;
  858			timeQuantum += OneClockCycleInTime;
  859			grossRuntime += OneClockCycleInTime;
  860			grossExecutionTime += 2 * OneClockCycleInTime;
  861			clock += 1;
  862			loadtracker += OneClockCycleInTime;
  863			timeout += 1;
  864			int valueToCompareBRP = Integer.parseInt(
  865					GPR[Integer.parseInt(Accumulator, 2)].substring(1, 32), 2);
  866			int signOfValueToCompareBRP = Integer.parseInt(
  867					GPR[Integer.parseInt(Accumulator, 2)].substring(0, 1));
  868			if (signOfValueToCompareBRP == 1) {
  869			valueToCompareBRP = valueToCompareBRP * -1;
  870			}
  871	
  872			if (valueToCompareBRP > 0) {
  873			VirtualPC = Integer.parseInt(virtualEffectiveAddress, 2) - 1;
  874			}
  875			break;
  876		case BRZ :
  877			executionTime += 1;
  878			cumulativeTimeByJob += OneClockCycleInTime;
  879			timeQuantum += OneClockCycleInTime;
  880			grossRuntime += OneClockCycleInTime;
  881			grossExecutionTime += 2 * OneClockCycleInTime;
  882			clock += 1;
  883			loadtracker += OneClockCycleInTime;
  884			timeout += 1;
  885			int valueToCompareBRZ = Integer.parseInt(
  886					GPR[Integer.parseInt(Accumulator, 2)].substring(1, 32), 2);
  887			int signOfValueToCompareBRZ = Integer.parseInt(
  888					GPR[Integer.parseInt(Accumulator, 2)].substring(0, 1));
  889			if (signOfValueToCompareBRZ == 1) {
  890			valueToCompareBRZ = valueToCompareBRZ * -1;
  891			}
  892	
  893			if (valueToCompareBRZ == 0) {
  894			VirtualPC = Integer.parseInt(virtualEffectiveAddress, 2) - 1;
  895			}
  896			break;







2016-04-29 00:34                    CPU.java                     Page 17


  897		case BRL :
  898			executionTime += 2;
  899			clock += 2 * OneClockCycleInTime;
  900			loadtracker += OneClockCycleInTime;
  901			cumulativeTimeByJob += 2 * OneClockCycleInTime;
  902			timeQuantum += OneClockCycleInTime;
  903			grossRuntime += 2 * OneClockCycleInTime;
  904			grossExecutionTime += 2 * OneClockCycleInTime;
  905			timeout += 2;
  906			// VirtualPC = convertVirtualAddressToPhysical(VirtualPC);
  907			if (VirtualPC == -1) {
  908			ReturnToScheduler = true;
  909			runningPCB.getFirst().currentOperation = "Error";
  910			ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  911			errorHandler.HandleError(ErrorHandler.ADDRESS_OUT_OF_RANGE);
  912			runningPCB.getFirst().errorDescription = "Address Out Of Range";
  913			hasMore = false;
  914			writeOutput("Read");
  915			runningPCB.removeFirst();
  916			TimeLost += cumulativeTimeByJob;
  917			break;
  918			}
  919			// Target = HEXBIN(memory.Mem("READ", PC, Target));
  920			Target = Integer.toBinaryString(VirtualPC);
  921			GPR[Integer.parseInt(Accumulator, 2)] = Target;
  922			VirtualPC = Integer.parseInt(virtualEffectiveAddress, 2) - 1;
  923			break;
  924		case AND :
  925			executionTime += 1;
  926			cumulativeTimeByJob += OneClockCycleInTime;
  927			timeQuantum += OneClockCycleInTime;
  928			grossRuntime += OneClockCycleInTime;
  929			grossExecutionTime += 2 * OneClockCycleInTime;
  930			clock += 1;
  931			loadtracker += OneClockCycleInTime;
  932			timeout += 1;
  933			R1 = HEXBIN(
  934					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2), R1));
  935			GPR[Integer.parseInt(Accumulator, 2)] = ALU
  936					.And(GPR[Integer.parseInt(Accumulator, 2)], R1);
  937			break;
  938		case OR :
  939			executionTime += 1;
  940			cumulativeTimeByJob += OneClockCycleInTime;
  941			timeQuantum += OneClockCycleInTime;
  942			grossRuntime += OneClockCycleInTime;
  943			grossExecutionTime += 2 * OneClockCycleInTime;
  944			clock += 1;
  945			loadtracker += OneClockCycleInTime;
  946			timeout += 1;
  947			R1 = HEXBIN(
  948					memory.Mem("READ", Integer.parseInt(effectiveAddress, 2), R1));
  949			GPR[Integer.parseInt(Accumulator, 2)] = ALU
  950					.Or(GPR[Integer.parseInt(Accumulator, 2)], R1);
  951			break;
  952		case RD :







2016-04-29 00:34                    CPU.java                     Page 18


  953			executionTime += 2;
  954			ioTime += 8;
  955			/*
  956			 * IO handler is used because CPU should not directly do the I/O
  957			 * operations
  958			 */
  959			/* 8 clock cycles for IO and two for instruction */
  960			clock += 10 * OneClockCycleInTime;
  961			loadtracker += 10 * OneClockCycleInTime;
  962			cumulativeTimeByJob += 10 * OneClockCycleInTime;
  963			timeQuantum += 10 * OneClockCycleInTime;
  964			grossRuntime += 10 * OneClockCycleInTime;
  965			grossExecutionTime += 2 * OneClockCycleInTime;
  966			grossIOTime += 10;
  967			timeout = 0;
  968			VirtualPC++;
  969			runningPCB.getFirst().numberOfTurns = 1;
  970			runningPCB.getFirst().TimeQuantum = timeQuantum;
  971			writeCurrentStateToPCB("Read");
  972			if (runningPCB.getFirst().DataPagesOnDisk.length == 0) {
  973			ReturnToScheduler = true;
  974			runningPCB.getFirst().currentOperation = "Error";
  975			ErrorHandler.setJobID(runningPCB.getFirst().jobID);
  976			errorHandler.HandleError(ErrorHandler.MISSING_DATA);
  977			runningPCB.getFirst().errorDescription = "Missing Data";
  978			hasMore = false;
  979			writeOutput("Read");
  980			TimeLost += cumulativeTimeByJob;
  981			break;
  982	
  983			}
  984			dataPageToLoad = Integer.parseInt(runningPCB
  985					.getFirst().DataPagesOnDisk[runningPCB.getFirst().readPointer
  986							/ 4]);
  987			dataPageOffset = runningPCB.getFirst().readPointer % 4;
  988			runningPCB.getFirst().readPointer++;
  989			String data = "";
  990			for (int i = 0; i < 4; i++) {
  991			data += disk.disk[(dataPageToLoad * 16 + dataPageOffset * 4) + i];
  992			}
  993			for (int i = 0, j = 0; i < data.length(); i = i + 8, j++) {
  994			try {
  995			memory.Mem("WRIT",
  996					Integer.parseInt(
  997							convertAddFromVirtualToReal(virtualEffectiveAddress), 2)
  998					+ j, data.substring(i, i + 8));
  999			} catch (NumberFormatException e) {
 1000			System.out.print("");
 1001			}
 1002			try {
 1003			runningPCB.getFirst().pageFaultBits
 1004					.set(Integer.parseInt(virtualEffectiveAddress, 2) / 16, "111");
 1005			} catch (IndexOutOfBoundsException e) {
 1006			System.out.print("");
 1007			}
 1008			}







2016-04-29 00:34                    CPU.java                     Page 19


 1009			runningPCB.getFirst().resultOfReadOperation = data;
 1010			break;
 1011		case WR :
 1012			executionTime += 2;
 1013			ioTime += 8;
 1014			/*
 1015			 * IO handler is used because CPU should not directly do the I/O
 1016			 * operations
 1017			 */
 1018			/* 8 clock cycles for IO and two for instruction */
 1019			clock += 10 * OneClockCycleInTime;
 1020			loadtracker += 10 * OneClockCycleInTime;
 1021			cumulativeTimeByJob += 10 * OneClockCycleInTime;
 1022			timeQuantum += 10 * OneClockCycleInTime;
 1023			grossRuntime += 10 * OneClockCycleInTime;
 1024			grossExecutionTime += 2 * OneClockCycleInTime;
 1025			grossIOTime += 10;
 1026			timeout = 0;
 1027			VirtualPC++;
 1028			runningPCB.getFirst().numberOfTurns = 1;
 1029			runningPCB.getFirst().TimeQuantum = timeQuantum;
 1030			writeCurrentStateToPCB("Write");
 1031			if (runningPCB.getFirst().OutputPagesOnDisk.length == 0
 1032					|| runningPCB.getFirst().writePointer >= runningPCB
 1033							.getFirst().OutputPagesOnDisk.length * 16) {
 1034			ReturnToScheduler = true;
 1035			// System.out.println("OOPS");
 1036			runningPCB.getFirst().currentOperation = "Error";
 1037			ErrorHandler.setJobID(runningPCB.getFirst().jobID);
 1038			errorHandler.HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
 1039			runningPCB.getFirst().errorDescription = "Insufficient Output Space";
 1040			hasMore = false;
 1041			writeOutput("Insufficient Output Space");
 1042			TimeLost += cumulativeTimeByJob;
 1043			break;
 1044			}
 1045			String ContentInAddress = "";
 1046			for (int i = 0; i < 4; i++) {
 1047			ContentInAddress += memory
 1048					.Mem("READ",
 1049							Integer.parseInt(convertAddFromVirtualToReal(
 1050									virtualEffectiveAddress), 2) + i,
 1051					ContentInAddress);
 1052			}
 1053			try {
 1054			diskOutPageToWrite = Integer.parseInt(runningPCB
 1055					.getFirst().OutputPagesOnDisk[runningPCB.getFirst().writePointer
 1056							/ 4]);
 1057			dataPageOffset = runningPCB.getFirst().writePointer % 4;
 1058			} catch (ArrayIndexOutOfBoundsException e) {
 1059			// System.out.println("OOPS");
 1060			ReturnToScheduler = true;
 1061			runningPCB.getFirst().currentOperation = "Error";
 1062			ErrorHandler.setJobID(runningPCB.getFirst().jobID);
 1063			errorHandler.HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
 1064			runningPCB.getFirst().errorDescription = "Insufficent Output space";







2016-04-29 00:34                    CPU.java                     Page 20


 1065			hasMore = false;
 1066			writeOutput("Insufficient Output Space");
 1067			TimeLost += cumulativeTimeByJob;
 1068			break;
 1069			}
 1070	
 1071			/*
 1072			 * one output line is 64 hex digits hence we append zeros if the content
 1073			 * in address is less than 64
 1074			 */
 1075			try {
 1076			for (int i = (diskOutPageToWrite * 16
 1077					+ dataPageOffset * 4), j = 0; i < (diskOutPageToWrite * 16
 1078							+ dataPageOffset * 4) + 4; i++, j += 8) {
 1079			disk.disk[i] = ContentInAddress.substring(j, j + 8);
 1080			}
 1081			} catch (StringIndexOutOfBoundsException e) {
 1082			System.out.print("");
 1083			}
 1084			runningPCB.getFirst().writePointer++;
 1085	
 1086			break;
 1087		case DMP :
 1088			clock += 1;
 1089			loadtracker += OneClockCycleInTime;
 1090			timeout += 1;
 1091			cumulativeTimeByJob += 1;
 1092			timeQuantum += OneClockCycleInTime;
 1093			grossRuntime += OneClockCycleInTime;
 1094			grossExecutionTime += OneClockCycleInTime;
 1095			executionTime += 1;
 1096			memory.Mem("DUMP", 0, nullString);
 1097			break;
 1098		}
 1099		return returnValue;
 1100		} catch (NumberFormatException e) {
 1101		ReturnToScheduler = true;
 1102		runningPCB.getFirst().currentOperation = "Error";
 1103		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
 1104		errorHandler.HandleError(ErrorHandler.ARTHEMATIC_ERROR);
 1105		runningPCB.getFirst().errorDescription = "Arithmetic Conversion Error";
 1106		hasMore = false;
 1107		writeOutput("Number conversion");
 1108		TimeLost += cumulativeTimeByJob;
 1109		return false;
 1110		}
 1111		}
 1112		/*
 1113		 * read 32 hex digits from the console and put it in memory locations EA to
 1114		 * EA+3
 1115		 */
 1116	
 1117		public void writeAggregateResults() {
 1118		int temp = Loader.getHolesNo();
 1119		int temp2 = Loader.getAvgHoleSize();
 1120		int temp3 = Loader.getPercentage();







2016-04-29 00:34                    CPU.java                     Page 21


 1121		try {
 1122		FileWriter statusWrite2 = new FileWriter("progressFile.txt", true);
 1123		statusWrite2.write("\n");
 1124		statusWrite2.write("Report for Batch:");
 1125		statusWrite2.write("\n");
 1126		statusWrite2.write(String.format("%-53s %-15s", "Current Clock Value:(HEX)",
 1127				Integer.toHexString(clock)));
 1128		statusWrite2.write("\n");
 1129		String tempo1 = String.format("%.2f",
 1130				(Float.parseFloat(Integer.toString(grossIOTime)) / Loader.NOJITB));
 1131		statusWrite2.write(String.format("%-53s %-15s",
 1132				"Mean user job run time:(DEC)", tempo1));
 1133		statusWrite2.write("\n");
 1134		tempo1 = String.format("%.2f",
 1135				(Float.parseFloat(Integer.toString(grossIOTime)) / Loader.NOJITB));
 1136		statusWrite2.write(String.format("%-53s %-15s",
 1137				"Mean user job I/O time:(DEC)", tempo1));
 1138		statusWrite2.write("\n");
 1139		tempo1 = String.format("%.2f",
 1140				(Float.parseFloat(Integer.toString(grossExecutionTime))
 1141						/ Loader.NOJITB));
 1142		statusWrite2.write(String.format("%-53s %-15s",
 1143				"Mean user job execution time:(DEC)", tempo1));
 1144		statusWrite2.write("\n");
 1145		tempo1 = String.format("%.2f",
 1146				(Float.parseFloat(Integer.toString(clock)) / Loader.NOJITB));
 1147		statusWrite2.write(String.format("%-53s %-15s",
 1148				"Mean user job time in the System:(DEC)", tempo1));
 1149		statusWrite2.write("\n");
 1150		tempo1 = String.format("%.2f",
 1151				(Float.parseFloat(Integer.toString(grossPFHtime)) / Loader.NOJITB));
 1152		statusWrite2.write(String.format("%-53s %-15s",
 1153				"Mean user job page fault handling time(DEC):", tempo1));
 1154		statusWrite2.write("\n");
 1155		statusWrite2.write(String.format("%-53s %-15s", "Total CPU idle time(HEX):",
 1156				Integer.toHexString(ideleTime)));
 1157		statusWrite2.write("\n");
 1158		statusWrite2.write(String.format("%-53s %-15s",
 1159				"Time lost due to abnormally terminated jobs(HEX):", 0));
 1160		statusWrite2.write("\n");
 1161		statusWrite2.write(String.format("%-53s %-15s",
 1162				"Number of jobs that terminated normally(DEC):",
 1163				normalTermination));
 1164		statusWrite2.write("\n");
 1165		statusWrite2.write(String.format("%-53s %-15s",
 1166				"Number of jobs that terminated abnormally(DEC):",
 1167				(Loader.NOJITB - normalTermination)));
 1168		statusWrite2.write("\n");
 1169		statusWrite2.write(String.format("%-53s %-15s",
 1170				"Total Time lost due to Suspected Infinite jobs(HEX):",
 1171				suspectedInputTimeout));
 1172		statusWrite2.write("\n");
 1173		statusWrite2.write(String.format("%-53s %-15s",
 1174				"ID's of jobs considered Infinite(DEC):", suspectedInfiniteJobID));
 1175		statusWrite2.write("\n");
 1176		statusWrite2.write(







2016-04-29 00:34                    CPU.java                     Page 22


 1177				String.format("%-53s %-15s", "Total Number of page faults(HEX):",
 1178						Integer.toHexString((grossPFHtime / 5))));
 1179		statusWrite2.write("\n");
 1180		statusWrite2.write(String.format("%-53s %-15s",
 1181				"percentage of Disk Occupied(DEC):", temp3));
 1182		statusWrite2.write("\n");
 1183		statusWrite2
 1184				.write(String.format("%-53s %-15s", "Number of holes(DEC):", temp));
 1185		statusWrite2.write("\n");
 1186		statusWrite2.write(
 1187				String.format("%-53s %-15s", "average size of holes(DEC):", temp2));
 1188		statusWrite2.write("\n");
 1189		statusWrite2.write(
 1190				String.format("%-53s %-15s", "average size of holes(DEC):", temp2));
 1191		statusWrite2.write("\n");
 1192		statusWrite2.write(String.format("%-53s %-15s",
 1193				"Maximum size of subqueue 1(DEC):", maxSubqueue1Size));
 1194		statusWrite2.write("\n");
 1195		statusWrite2.write(String.format("%-53s %-15s",
 1196				"Maximum size of subqueue 2:(DEC)", maxSubqueue2Size));
 1197		statusWrite2.write("\n");
 1198		statusWrite2.write(String.format("%-53s %-15s",
 1199				"Maximum size of subqueue 3:(DEC)", maxSubqueue3Size));
 1200		statusWrite2.write("\n");
 1201		statusWrite2.write(String.format("%-53s %-15s",
 1202				"Maximum size of subqueue 4:(DEC)", maxSubqueue4Size));
 1203		statusWrite2.write("\n");
 1204		String tempo = String.format("%.2f", (cumulativeSubQueu1size / queueCount));
 1205		statusWrite2.write(String.format("%-53s %-15s",
 1206				"Average size of subqueue 1(DEC)", tempo));
 1207		statusWrite2.write("\n");
 1208		tempo = String.format("%.2f", (cumulativeSubQueu2size / queueCount));
 1209		statusWrite2.write(String.format("%-53s %-15s",
 1210				"Average size of subqueue 2(DEC)", tempo));
 1211		statusWrite2.write("\n");
 1212		tempo = String.format("%.2f", (cumulativeSubQueu3size / queueCount));
 1213		statusWrite2.write(String.format("%-53s %-15s",
 1214				"Average size of subqueue 3(DEC)", tempo));
 1215		statusWrite2.write("\n");
 1216		tempo = String.format("%.2f", (cumulativeSubQueu4size / queueCount));
 1217		statusWrite2.write(String.format("%-53s %-15s",
 1218				"Average size of subqueue 4(DEC)", tempo));
 1219		statusWrite2.write("\n");
 1220		statusWrite2.close();
 1221		} catch (IOException e) {
 1222		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
 1223		errorHandler.HandleError(ErrorHandler.FILE_NOT_FOUND);
 1224		hasMore = false;
 1225		ReturnToScheduler = true;
 1226		}
 1227	
 1228		}
 1229	
 1230		private String convertAddFromVirtualToReal(String addr) {
 1231		try {
 1232		addr = binhex(addr);







2016-04-29 00:34                    CPU.java                     Page 23


 1233		String temp = addr.toString();
 1234		int PageTableIndexDec = Integer.parseInt(temp.substring(0, 1), 16);
 1235		String pageTableOffset = temp.substring(1, 2);
 1236		/* condition will be true if the page is not in memory */
 1237		if (runningPCB.getFirst().pageFaultBits.get(PageTableIndexDec)
 1238				.substring(0, 1).equals("0")) {
 1239		String pageNumberOnMemtoReplace = "";
 1240		String pageNumberOnDisktoReplace;
 1241		String pageNumberOnDisktoBring;
 1242		int pageIndexToReplace = -1;
 1243		boolean isPageClean = true;
 1244		cumulativeTimeByJob += 5;
 1245		timeQuantum += 5;
 1246		grossRuntime += 5;
 1247		pageFaultHandlingTime += 5;
 1248		grossPFHtime += 5;
 1249		/* Victim selection stage 1 not used and clean */
 1250		for (int i = 0; i < runningPCB.getFirst().ProgramPagesOnMem.length; i++) {
 1251		if (runningPCB.getFirst().pageFaultBits.get(i).substring(0, 1).equals("1")
 1252				&& runningPCB.getFirst().pageFaultBits.get(i).substring(1, 2)
 1253						.equals("0")
 1254				&& runningPCB.getFirst().pageFaultBits.get(i).substring(2, 3)
 1255						.equals("0")) {
 1256		pageIndexToReplace = i;
 1257		break;
 1258		}
 1259		}
 1260		/* Victim selection Stage 2 used but still clean */
 1261		if (pageIndexToReplace == -1) {
 1262		for (int i = 0; i < runningPCB.getFirst().ProgramPagesOnMem.length; i++) {
 1263		if (runningPCB.getFirst().pageFaultBits.get(i).substring(0, 1).equals("1")
 1264				&& runningPCB.getFirst().pageFaultBits.get(i).substring(1, 2)
 1265						.equals("1")
 1266				&& runningPCB.getFirst().pageFaultBits.get(i).substring(2, 3)
 1267						.equals("0")) {
 1268		pageIndexToReplace = i;
 1269		break;
 1270		}
 1271		}
 1272		}
 1273		/* Victim selection Stage 3 used and dirty */
 1274		if (pageIndexToReplace == -1) {
 1275		for (int i = 0; i < runningPCB.getFirst().ProgramPagesOnMem.length; i++) {
 1276		if (runningPCB.getFirst().pageFaultBits.get(i).substring(0, 1).equals("1")
 1277				&& runningPCB.getFirst().pageFaultBits.get(i).substring(1, 2)
 1278						.equals("1")
 1279				&& runningPCB.getFirst().pageFaultBits.get(i).substring(2, 3)
 1280						.equals("1")) {
 1281		pageIndexToReplace = i;
 1282		isPageClean = false;
 1283		break;
 1284		}
 1285		}
 1286		}
 1287		if (pageIndexToReplace == -1) {
 1288		ErrorHandler.setJobID(runningPCB.getFirst().jobID);







2016-04-29 00:34                    CPU.java                     Page 24


 1289		errorHandler.HandleError(ErrorHandler.OUT_OF_BOUNDS);
 1290		hasMore = false;
 1291		ReturnToScheduler = true;
 1292		return "";
 1293		} else {
 1294		/* Page is dirty copy it to disk */
 1295		if (isPageClean == false) {
 1296		String contentInMemPage = "";
 1297		pageNumberOnMemtoReplace = runningPCB
 1298				.getFirst().ProgramPagesOnMem[pageIndexToReplace];
 1299		pageNumberOnDisktoReplace = runningPCB
 1300				.getFirst().ProgramPagesOnDisk[pageIndexToReplace];
 1301		for (int i = 0; i < 16; i++) {
 1302		contentInMemPage += memory.Mem("READ",
 1303				Integer.parseInt(pageNumberOnMemtoReplace) * 16 + i, "");
 1304		}
 1305		for (int i = (Integer.parseInt(pageNumberOnDisktoReplace)
 1306				* 16), j = 0; i < (Integer.parseInt(pageNumberOnDisktoReplace) * 16)
 1307						+ 16; i++, j = j + 8) {
 1308		disk.disk[i] = contentInMemPage.substring(j, j + 8);
 1309		}
 1310		runningPCB.getFirst().pageFaultBits.set(pageIndexToReplace,
 1311				runningPCB.getFirst().pageFaultBits.get(pageIndexToReplace)
 1312						.substring(0, 2) + "0");
 1313		}
 1314		/* replace the page with the page from disk */
 1315		String contentInDisk = "";
 1316		pageNumberOnDisktoBring = runningPCB
 1317				.getFirst().ProgramPagesOnDisk[PageTableIndexDec];
 1318		for (int i = Integer.parseInt(pageNumberOnDisktoBring)
 1319				* 16; i < (Integer.parseInt(pageNumberOnDisktoBring) * 16)
 1320						+ 16; i++) {
 1321		contentInDisk += disk.disk[i];
 1322		}
 1323		pageNumberOnMemtoReplace = runningPCB
 1324				.getFirst().ProgramPagesOnMem[pageIndexToReplace];
 1325		for (int i = Integer.parseInt(pageNumberOnMemtoReplace)
 1326				* 16, j = 0; i < (Integer.parseInt(pageNumberOnMemtoReplace) * 16)
 1327						+ 16; i++, j = j + 8) {
 1328		memory.Mem("WRIT", i, contentInDisk.substring(j, j + 8));
 1329		}
 1330		/* update the bits for the page replaced and fetched */
 1331		runningPCB.getFirst().pageFaultBits.set(pageIndexToReplace, "000");
 1332		runningPCB.getFirst().pageFaultBits.set(PageTableIndexDec, "100");
 1333		runningPCB.getFirst().ProgramPagesOnMem[pageIndexToReplace] = null;
 1334		runningPCB
 1335				.getFirst().ProgramPagesOnMem[PageTableIndexDec] = pageNumberOnMemtoReplace;
 1336		}
 1337		}
 1338		String pageNumberToLook = Integer.toHexString(Integer.parseInt(
 1339				runningPCB.getFirst().ProgramPagesOnMem[PageTableIndexDec]));
 1340		runningPCB.getFirst().pageFaultBits.set(PageTableIndexDec,
 1341				"11" + runningPCB.getFirst().pageFaultBits.get(PageTableIndexDec)
 1342						.substring(2, 3));
 1343		String address = HEXBIN(pageNumberToLook + pageTableOffset);
 1344		return address;







2016-04-29 00:34                    CPU.java                     Page 25


 1345		} catch (Exception e) {
 1346		return "";
 1347		}
 1348		}
 1349	
 1350		private void writeOutput(String Reason) {
 1351		try {
 1352		FileWriter fw2 = new FileWriter("progressFile.txt", true);
 1353		fw2.write("\n");
 1354		fw2.write(
 1355				String.format("%-40s %-15s", "Completed Execution for jobID(DEC):",
 1356						runningPCB.getFirst().jobID));
 1357		fw2.write("\n");
 1358		fw2.write(String.format("%-40s %-15s",
 1359				"Current value of the clock(Decimal):", clock));
 1360		fw2.write("\n");
 1361		fw2.write(String.format("%-40s %-15s", "clock at load time(hex):", Integer
 1362				.toHexString(runningPCB.getFirst().timeJobEnteredTheSystem)));
 1363		fw2.write("\n");
 1364		fw2.write(String.format("%-40s %-15s", "Clock at termination time(hex):",
 1365				Integer.toHexString(clock)));
 1366		fw2.write("\n");
 1367		fw2.write(String.format("%-40s %-15s", "Number of chances at the CPU:",
 1368				runningPCB.getFirst().numberOfChancesCPU));
 1369		fw2.write("\n");
 1370		fw2.write("job Output(Hex):");
 1371		String temp = "";
 1372		if (Reason.equals("Halt")) {
 1373		for (int j = 0; j < runningPCB.getFirst().OutputPagesOnDisk.length; j++) {
 1374		for (int i = 0; i < 16; i++) {
 1375		if (disk.disk[Integer.parseInt(runningPCB.getFirst().OutputPagesOnDisk[j])
 1376				* 16 + i] != null) {
 1377		if (i % 4 == 0) {
 1378		fw2.write("\n");
 1379		}
 1380		// fw2.write(disk.disk[Integer.parseInt(runningPCB.getFirst().OutputPagesOnDisk[j])
 1381		// * 16 + i]);
 1382		temp += disk.disk[Integer
 1383				.parseInt(runningPCB.getFirst().OutputPagesOnDisk[j]) * 16 + i];
 1384		if (temp.length() == 32) {
 1385		fw2.write(String.format("%10s %10s %10s %10s", temp.substring(0, 8),
 1386				temp.substring(8, 16), temp.substring(16, 24),
 1387				temp.substring(24, 32)));
 1388		temp = "";
 1389		}
 1390		}
 1391		}
 1392		}
 1393		}
 1394		String temp2 = "";
 1395		if (memoryDumpArray.size() > 0) {
 1396		fw2.write("\n");
 1397		fw2.write("Memory Dump:");
 1398		fw2.write("\n");
 1399		for (int i = 0; i < memoryDumpArray.size(); i++) {
 1400		// fw2.write(memoryDumpArray.get(i));







2016-04-29 00:34                    CPU.java                     Page 26


 1401		temp2 += memoryDumpArray.get(i);
 1402		if (temp2.length() == 32) {
 1403		if (temp2.substring(0, 8).equals("nullnull")) {
 1404		fw2.write(String.format("%10s %10s %10s %10s", "null", "null", "null",
 1405				"null"));
 1406		fw2.write("\n");
 1407		temp2 = "";
 1408		} else {
 1409		fw2.write(String.format("%10s %10s %10s %10s", temp2.substring(0, 8),
 1410				temp2.substring(8, 16), temp2.substring(16, 24),
 1411				temp2.substring(24, 32)));
 1412		fw2.write("\n");
 1413		temp2 = "";
 1414		}
 1415		}
 1416		}
 1417		}
 1418		fw2.write("\n");
 1419		if (Reason.equals("Halt")) {
 1420		fw2.write(String.format("%-40s %-15s", "Nature of termination:", "Normal"));
 1421		} else if (Reason.equals("Read")) {
 1422		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1423				"Read Error"));
 1424		} else if (Reason.equals("Wead")) {
 1425		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1426				"Write Error"));
 1427		} else if (Reason.equals("Divide by Zero")) {
 1428		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1429				"Arithematic Error"));
 1430		} else if (Reason.equals("Number conversion")) {
 1431		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1432				"Problem with number conversion"));
 1433		} else if (Reason.equals("Illegal Character")) {
 1434		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1435				"Illegal character"));
 1436		} else if (Reason.equals("System Error")) {
 1437		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1438				"System Error"));
 1439		} else if (Reason.equals("Overflow")) {
 1440		fw2.write(
 1441				String.format("%-40s %-15s", "Nature of termination:", "Overflow"));
 1442		} else if (Reason.equals("IO")) {
 1443		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1444				"IO Exception"));
 1445		} else if (Reason.equals("Invalid Pointer")) {
 1446		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1447				"Invalid Pointer"));
 1448		} else if (Reason.equals("Infinite")) {
 1449		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1450				"Suspected Infinite Job"));
 1451		} else if (Reason.equals("Arithematic")) {
 1452		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1453				"Arithematic Error"));
 1454		} else if (Reason.equals("Insufficient Output Space")) {
 1455		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1456				"Insufficient Output space"));







2016-04-29 00:34                    CPU.java                     Page 27


 1457		} else if (Reason.equals("Invalid Opcode")) {
 1458		fw2.write(String.format("%-40s %-15s", "Nature of termination:",
 1459				"Invalid Opcode"));
 1460		}
 1461		fw2.write("\n");
 1462		fw2.write(String.format("%-40s %-15s", "Runtime(Decimal):",
 1463				runningPCB.getFirst().cumilativeTimeUsedByJob));
 1464		fw2.write("\n");
 1465		fw2.write(String.format("%-40s %-15s", "TurnAroundTime(Decimal):",
 1466				(clock - runningPCB.getFirst().timeJobEnteredTheSystem)));
 1467		fw2.write("\n");
 1468		fw2.write(String.format("%-40s %-15s", "Execution Time(Decimal):",
 1469				runningPCB.getFirst().cumilativeTimeUsedByJob));
 1470		fw2.write("\n");
 1471		fw2.write(String.format("%-40s %-15s", "Page Fault Handling Time(Decimal):",
 1472				runningPCB.getFirst().pageFaultHandlingTime));
 1473		fw2.write("\n");
 1474		fw2.write("------------------------------------------------------");
 1475		fw2.write("\n");
 1476		fw2.close();
 1477		} catch (IOException e) {
 1478		System.out.print("");
 1479		}
 1480	
 1481		}
 1482	
 1483		public String addBinary(String a, String b) {
 1484		if (a == null || a.length() == 0)
 1485			return b;
 1486		if (b == null || b.length() == 0)
 1487			return a;
 1488	
 1489		int pa = a.length() - 1;
 1490		int pb = b.length() - 1;
 1491	
 1492		int flag = 0;
 1493		StringBuilder sb = new StringBuilder();
 1494		while (pa >= 0 || pb >= 0) {
 1495		int va = 0;
 1496		int vb = 0;
 1497	
 1498		if (pa >= 0) {
 1499		va = a.charAt(pa) == '0' ? 0 : 1;
 1500		pa--;
 1501		}
 1502		if (pb >= 0) {
 1503		vb = b.charAt(pb) == '0' ? 0 : 1;
 1504		pb--;
 1505		}
 1506	
 1507		int sum = va + vb + flag;
 1508		if (sum >= 2) {
 1509		sb.append(String.valueOf(sum - 2));
 1510		flag = 1;
 1511		} else {
 1512		flag = 0;







2016-04-29 00:34                    CPU.java                     Page 28


 1513		sb.append(String.valueOf(sum));
 1514		}
 1515		}
 1516	
 1517		if (flag == 1) {
 1518		sb.append("1");
 1519		}
 1520	
 1521		String reversed = sb.reverse().toString();
 1522		return reversed;
 1523		}
 1524	
 1525		private void restoreStateOfProcess() {
 1526		VirtualPC = runningPCB.getFirst().PC;
 1527		instructionRegister = runningPCB.getFirst().registers[0];
 1528		PC = Integer.parseInt(runningPCB.getFirst().registers[1]);
 1529		Accumulator = runningPCB.getFirst().registers[2];
 1530		IndexRegister = runningPCB.getFirst().registers[3];
 1531		R1 = runningPCB.getFirst().registers[4];
 1532		R2 = runningPCB.getFirst().registers[5];
 1533		R3 = runningPCB.getFirst().registers[6];
 1534		R4 = runningPCB.getFirst().registers[7];
 1535		R5 = runningPCB.getFirst().registers[8];
 1536		R6 = runningPCB.getFirst().registers[9];
 1537		R7 = runningPCB.getFirst().registers[10];
 1538		R8 = runningPCB.getFirst().registers[11];
 1539		R9 = runningPCB.getFirst().registers[12];
 1540		R10 = runningPCB.getFirst().registers[13];
 1541		R11 = runningPCB.getFirst().registers[14];
 1542		Target = runningPCB.getFirst().registers[15];
 1543		ioTime = runningPCB.getFirst().iotime;
 1544		addressOfOperand = runningPCB.getFirst().AddressRFWT;
 1545		for (int i = 0; i < runningPCB.getFirst().GeneralPurpouse.length; i++) {
 1546		GPR[i] = runningPCB.getFirst().GeneralPurpouse[i];
 1547		}
 1548		}
 1549	
 1550		private void writeCurrentStateToPCB(String operation) {
 1551		runningPCB.getFirst().PC = VirtualPC;
 1552		runningPCB.getFirst().registers = new String[16];
 1553		runningPCB.getFirst().GeneralPurpouse = new String[GPR.length];
 1554		String[] temp = new String[16];
 1555		temp[0] = instructionRegister;
 1556		temp[1] = Integer.toString(VirtualPC);
 1557		temp[2] = Accumulator;
 1558		temp[3] = IndexRegister;
 1559		temp[4] = R1;
 1560		temp[5] = R2;
 1561		temp[6] = R3;
 1562		temp[7] = R4;
 1563		temp[8] = R5;
 1564		temp[9] = R6;
 1565		temp[10] = R7;
 1566		temp[11] = R8;
 1567		temp[12] = R9;
 1568		temp[13] = R10;







2016-04-29 00:34                    CPU.java                     Page 29


 1569		temp[14] = R11;
 1570		temp[15] = Target;
 1571		runningPCB.getFirst().registers = temp;
 1572		runningPCB.getFirst().cumilativeTimeUsedByJob = cumulativeTimeByJob;
 1573		// runningPCB.getFirst().currentSubqueueLevel = currentLevel;
 1574		runningPCB.getFirst().pageFaultHandlingTime = pageFaultHandlingTime;
 1575		runningPCB.getFirst().timeJobEnteredTheSystem = timeJobEnteredTheSystem;
 1576		runningPCB.getFirst().AddressRFWT = addressOfOperand;
 1577		runningPCB.getFirst().TimeQuantum += timeQuantum;
 1578		runningPCB.getFirst().iotime = ioTime;
 1579		runningPCB.getFirst().numberOfTurns = numberOfTurns;
 1580		runningPCB.getFirst().currentSubqueueLevel = currentLevel;
 1581		runningPCB.getFirst().numberOfChancesCPU = chancesAtCPU;
 1582		for (int i = 0; i < GPR.length; i++) {
 1583		runningPCB.getFirst().GeneralPurpouse[i] = GPR[i];
 1584		}
 1585		if (operation.equals("Read")) {
 1586		runningPCB.getFirst().currentOperation = "Read";
 1587		hasMore = true;
 1588		} else if (operation.equals("Write")) {
 1589		runningPCB.getFirst().currentOperation = "Write";
 1590		hasMore = true;
 1591	
 1592		} else if (operation.equals("TimeOut")) {
 1593		runningPCB.getFirst().currentOperation = "TimeOut";
 1594		hasMore = true;
 1595		} else if (operation.equals("Halt")) {
 1596		runningPCB.getFirst().currentOperation = "Halt";
 1597		hasMore = false;
 1598		}
 1599		VirtualPC = 0;
 1600		ioTime = 0;
 1601		R1 = "";
 1602		R2 = "";
 1603		R3 = "";
 1604		R4 = "";
 1605		R5 = "";
 1606		R6 = "";
 1607		R7 = "";
 1608		R8 = "";
 1609		R9 = "";
 1610		R10 = "";
 1611		R11 = "";
 1612		PC = 0;
 1613		Accumulator = "";
 1614		instructionRegister = "";
 1615		IndexRegister = "";
 1616		indexToAdd = "";
 1617		addressOfOperand = "";
 1618		currentLevel = 0;
 1619		for (int i = 0; i < GPR.length; i++) {
 1620		GPR[i] = null;
 1621		}
 1622		ReturnToScheduler = true;
 1623		}
 1624	







2016-04-29 00:34                    CPU.java                     Page 30


 1625		public String addAddresses(String addr1, String addr2) {
 1626		/*
 1627		 * Maintaining the consistency of addresses as 32 bits by padding required
 1628		 * number of zeros in front of most significant bit
 1629		 */
 1630		int length1 = addr1.length();
 1631		if (length1 < 32) {
 1632		for (int i = 0; i < (32 - length1); i++) {
 1633		addr1 = "0" + addr1;
 1634		}
 1635		}
 1636		int length2 = addr2.length();
 1637		if (length2 < 32) {
 1638		for (int i = 0; i < (32 - length2); i++) {
 1639		addr2 = "0" + addr2;
 1640		}
 1641		}
 1642	
 1643		String sum = addBinary(addr1, addr2);
 1644	
 1645		return sum;
 1646		}
 1647	
 1648		public String fetchOpcode(String code) {
 1649		/*
 1650		 * converting the binary to hex values to decode the right opcode operation
 1651		 */
 1652		code = binhex(code);
 1653		return code;
 1654		}
 1655	
 1656		public opCode decodeOpcode(String code) {
 1657		opCode OpCode = null;
 1658		if (code.toLowerCase().equals("00")) {
 1659		return opCode.HLT;
 1660		}
 1661		if (code.toLowerCase().equals("01")) {
 1662		return opCode.LD;
 1663		}
 1664		if (code.toLowerCase().equals("02")) {
 1665		return opCode.ST;
 1666		}
 1667		if (code.toLowerCase().equals("03")) {
 1668		return opCode.AD;
 1669		}
 1670		if (code.toLowerCase().equals("04")) {
 1671		return opCode.SB;
 1672		}
 1673		if (code.toLowerCase().equals("05")) {
 1674		return opCode.MPY;
 1675		}
 1676		if (code.toLowerCase().equals("06")) {
 1677		return opCode.DIV;
 1678		}
 1679		if (code.toLowerCase().equals("07")) {
 1680		return opCode.SHL;







2016-04-29 00:34                    CPU.java                     Page 31


 1681		}
 1682		if (code.toLowerCase().equals("08")) {
 1683		return opCode.SHR;
 1684		}
 1685		if (code.toLowerCase().equals("09")) {
 1686		return opCode.BRM;
 1687		}
 1688		if (code.toLowerCase().equals("0a")) {
 1689		return opCode.BRP;
 1690		}
 1691		if (code.toLowerCase().equals("0b")) {
 1692		return opCode.BRZ;
 1693		}
 1694		if (code.toLowerCase().equals("0c")) {
 1695		return opCode.BRL;
 1696		}
 1697		if (code.toLowerCase().equals("0d")) {
 1698		return opCode.AND;
 1699		}
 1700		if (code.toLowerCase().equals("0e")) {
 1701		return opCode.OR;
 1702		}
 1703		if (code.toLowerCase().equals("0f")) {
 1704		return opCode.RD;
 1705		}
 1706		if (code.toLowerCase().equals("10")) {
 1707		return opCode.WR;
 1708		}
 1709		if (code.toLowerCase().equals("11")) {
 1710		return opCode.DMP;
 1711		}
 1712	
 1713		return OpCode;
 1714	
 1715		}
 1716	
 1717		private String binhex(String binaryValue) {
 1718		try {
 1719		if (!binaryValue.equals("")) {
 1720		String value = new BigInteger(binaryValue, 2).toString(16);
 1721		return String.format("%2s", value).replace(" ", "0");
 1722		} else {
 1723		return null;
 1724		}
 1725		} catch (Exception e) {
 1726		runningPCB.getFirst().currentOperation = "Error";
 1727		ErrorHandler.setJobID(runningPCB.getFirst().jobID);
 1728		errorHandler.HandleError(ErrorHandler.ARTHEMATIC_ERROR);
 1729		runningPCB.getFirst().errorDescription = "Arithematic Error";
 1730		hasMore = false;
 1731		ReturnToScheduler = true;
 1732		writeOutput("Arithematic");
 1733		return null;
 1734		}
 1735		}
 1736	







2016-04-29 00:34                    CPU.java                     Page 32


 1737		/* This method will take value in hexadecimal and return a binary value */
 1738		public String HEXBIN(String hexValue) {
 1739		String value = new BigInteger(hexValue, 16).toString(2);
 1740		return String.format("%32s", value).replace(" ", "0");
 1741		}
 1742	}
 1743	
 1744	/*
 1745	 * Name: Gautham Brahma Ponnaganti. Course No.: CS5323 Assignment title:OS
 1746	 * Project PHASE I Date:2-22-2016 Global Variables: -errorHandler: This is used
 1747	 * to call the error handler because it can be used in case an error occurs
 1748	 * 
 1749	 *
 1750	 * Brief description: This is used for arithmetic operations which is like an
 1751	 * ALU in a computer system.
 1752	 */
 1753	class ArthematicOperations {
 1754		ErrorHandler errorHandler = new ErrorHandler();
 1755	
 1756		public String Add(String Operand1, String Operand2) {
 1757		try {
 1758		int signOfOperand1 = Integer.parseInt(Operand1.substring(0, 1));
 1759		int signOfOperand2 = Integer.parseInt(Operand2.substring(0, 1));
 1760		int signOfResult = 0;
 1761		Operand1 = Operand1.substring(1, Operand1.length());
 1762		Operand2 = Operand2.substring(1, Operand2.length());
 1763		int x = Integer.parseInt(Operand1, 2);
 1764		int y = Integer.parseInt(Operand2, 2);
 1765		if (signOfOperand1 == 1) {
 1766		x = x * (-1);
 1767		}
 1768		if (signOfOperand2 == 1) {
 1769		y = y * (-1);
 1770		}
 1771		int result = x + y;
 1772		if (result < 0) {
 1773		signOfResult = 1;
 1774		result = result * -1;
 1775		}
 1776		String z = Integer.toBinaryString(result);
 1777		int length = z.length();
 1778		if (length < 31) {
 1779		for (int i = 0; i < (31 - length); i++) {
 1780		z = "0" + z;
 1781		}
 1782		}
 1783		if (signOfResult == 0) {
 1784		z = "0" + z;
 1785		} else if (signOfResult == 1) {
 1786		z = "1" + z;
 1787		}
 1788		return z;
 1789		} catch (ArithmeticException e) {
 1790		return "OVERFLOW";
 1791		}
 1792		}







2016-04-29 00:34                    CPU.java                     Page 33


 1793	
 1794		public String And(String Operand1, String Operand2) {
 1795		int result = Integer.parseInt(Operand1, 2) & Integer.parseInt(Operand2, 2);
 1796		return Integer.toBinaryString(result);
 1797		}
 1798	
 1799		public String Or(String Operand1, String Operand2) {
 1800		int result = Integer.parseInt(Operand1, 2) | Integer.parseInt(Operand2, 2);
 1801		return Integer.toBinaryString(result);
 1802		}
 1803	
 1804		public String Sub(String Operand1, String Operand2) {
 1805		String z;
 1806		int signOfOperand1 = Integer.parseInt(Operand1.substring(0, 1));
 1807		int signOfOperand2 = Integer.parseInt(Operand2.substring(0, 1));
 1808		int signOfResult = 0;
 1809		Operand1 = Operand1.substring(1, Operand1.length());
 1810		Operand2 = Operand2.substring(1, Operand2.length());
 1811		int x = Integer.parseInt(Operand1, 2);
 1812		int y = Integer.parseInt(Operand2, 2);
 1813		if (signOfOperand1 == 1) {
 1814		x = x * (-1);
 1815		}
 1816		if (signOfOperand2 == 1) {
 1817		y = y * (-1);
 1818		}
 1819		int result = x - y;
 1820		if (result < 0) {
 1821		signOfResult = 1;
 1822		result = result * -1;
 1823		}
 1824		z = Integer.toBinaryString(result);
 1825		int length = z.length();
 1826		if (length < 31) {
 1827		for (int i = 0; i < (31 - length); i++) {
 1828		z = "0" + z;
 1829		}
 1830		}
 1831		if (signOfResult == 0) {
 1832		z = "0" + z;
 1833		} else if (signOfResult == 1) {
 1834		z = "1" + z;
 1835		}
 1836	
 1837		return z;
 1838		}
 1839	
 1840		public String Mul(String Operand1, String Operand2) {
 1841		int signOfOperand1 = Integer.parseInt(Operand1.substring(0, 1));
 1842		int signOfOperand2 = Integer.parseInt(Operand2.substring(0, 1));
 1843		int signOfResult = 0;
 1844		Operand1 = Operand1.substring(1, Operand1.length());
 1845		Operand2 = Operand2.substring(1, Operand2.length());
 1846		int x = Integer.parseInt(Operand1, 2);
 1847		int y = Integer.parseInt(Operand2, 2);
 1848		if (signOfOperand1 == 1) {







2016-04-29 00:34                    CPU.java                     Page 34


 1849		x = x * (-1);
 1850		}
 1851		if (signOfOperand2 == 1) {
 1852		y = y * (-1);
 1853		}
 1854		int result = x * y;
 1855		if (result < 0) {
 1856		signOfResult = 1;
 1857		result = result * -1;
 1858		}
 1859		String z = Integer.toBinaryString(result);
 1860		int length = z.length();
 1861		if (length < 31) {
 1862		for (int i = 0; i < (31 - length); i++) {
 1863		z = "0" + z;
 1864		}
 1865		}
 1866		if (signOfResult == 0) {
 1867		z = "0" + z;
 1868		} else if (signOfResult == 1) {
 1869		z = "1" + z;
 1870		}
 1871	
 1872		return z;
 1873		}
 1874	
 1875		public String Div(String Operand1, String Operand2) {
 1876		int signOfOperand1 = Integer.parseInt(Operand1.substring(0, 1));
 1877		int signOfOperand2 = Integer.parseInt(Operand2.substring(0, 1));
 1878		int signOfResult = 0;
 1879		Operand1 = Operand1.substring(1, Operand1.length());
 1880		Operand2 = Operand2.substring(1, Operand2.length());
 1881		int x = Integer.parseInt(Operand1, 2);
 1882		int y = Integer.parseInt(Operand2, 2);
 1883		if (y == 0) {
 1884		return "DIVIDEBYZERO";
 1885		}
 1886		if (signOfOperand1 == 1) {
 1887		x = x * (-1);
 1888		}
 1889		if (signOfOperand2 == 1) {
 1890		y = y * (-1);
 1891		}
 1892		int result = x / y;
 1893		if (result < 0) {
 1894		signOfResult = 1;
 1895		result = result * -1;
 1896		}
 1897		String z = Integer.toBinaryString(result);
 1898		int length = z.length();
 1899		if (length < 31) {
 1900		for (int i = 0; i < (31 - length); i++) {
 1901		z = "0" + z;
 1902		}
 1903		}
 1904		if (signOfResult == 0) {







2016-04-29 00:34                    CPU.java                     Page 35


 1905		z = "0" + z;
 1906		} else if (signOfResult == 1) {
 1907		z = "1" + z;
 1908		}
 1909	
 1910		return z;
 1911		}
 1912	
 1913		public String ShiftLeft(String Operand1, String ShiftAmount) {
 1914		long operand = Long.parseLong(Operand1, 2);
 1915		int sftAmt = Integer.parseInt(ShiftAmount, 2);
 1916		long iResult = operand << sftAmt;
 1917		iResult = iResult % 1073741824;
 1918		String result = Long.toBinaryString(iResult);
 1919		int lnth = result.length();
 1920		if (lnth < 31) {
 1921		for (int i = 0; i < (31 - lnth); i++) {
 1922		result = "0" + result;
 1923		}
 1924		}
 1925		return result;
 1926		}
 1927	
 1928		public String ShiftRight(String Operand1, String ShiftAmount) {
 1929		long operand = Long.parseLong(Operand1, 2);
 1930		int sftAmt = Integer.parseInt(ShiftAmount, 2);
 1931		long iResult = operand >>> sftAmt;
 1932		iResult = iResult % 1073741824;
 1933		String result = Long.toBinaryString(iResult);
 1934		int lnth = result.length();
 1935		if (lnth < 31) {
 1936		for (int i = 0; i < (31 - lnth); i++) {
 1937		result = "0" + result;
 1938		}
 1939		}
 1940		return result;
 1941		}
 1942	
 1943	}
























2016-04-29 00:34                    Disk.java                     Page 1


    1	
    2	/*Global Variables:
    3	 *-SizeOfDisk:Specifies the size of the disk
    4	 *-disk:array which is used for storage as a disk simulation
    5	 *-spaceLedt:To keep track of empty space in disk.
    6	 *-jobTracerPair:used in Loader 
    7	 *-schedule:instance of scheduler
    8	 *
    9	 *Brief description: This class is the simulation of disk structure which holds data in a memory and have properties
   10	 *such as empty space, total size etc. 
   11	 *
   12	 */
   13	
   14	import java.util.ArrayList;
   15	public class Disk {
   16		int sizeOfDisk = 4096;// 16 times the size of memory
   17		String[] disk = new String[sizeOfDisk];
   18		int[] DiskPageTable = new int[sizeOfDisk / 16];// 256
   19		int spaceLeft = sizeOfDisk;
   20		public ArrayList<Integer> jobTracerPair = new ArrayList<Integer>();
   21		public ArrayList<ArrayList<Integer>> JobTracker = new ArrayList<ArrayList<Integer>>();
   22		Scheduler schedule = new Scheduler();
   23	
   24		public void disk() {
   25	
   26		}
   27	
   28		/* This is used to initialize disk page table from loader */
   29		public void intitalizePageTable() {
   30		for (int i = 0; i < DiskPageTable.length; i++) {
   31		DiskPageTable[i] = i;
   32		}
   33		}
   34	
   35		/* this method can be used by others to probe the disk space available */
   36		public int diskSpaceAvailable() {
   37		return spaceLeft;
   38		}
   39	
   40		public void DumpDisk() {
   41		for (int i = 0; i < disk.length; i++) {
   42		System.out.println(disk[i]);
   43		}
   44		}
   45	
   46		public void writeToDisk(ArrayList<String> pageContent, int PageTableIndex) {
   47		int FrameStartAddress = getFrameStartAddress(PageTableIndex);
   48		for (int i = FrameStartAddress, j = 0; i < FrameStartAddress
   49				+ 16; i++, j++) {
   50		disk[i] = pageContent.get(j);
   51		}
   52		}
   53	
   54		private int getFrameStartAddress(int pageTableIndex) {
   55		/*
   56		 * we are appending two zeros at the end which is same as multiplying by 16







2016-04-29 00:34                    Disk.java                     Page 2


   57		 * in decimal
   58		 */
   59		return DiskPageTable[pageTableIndex] * 16;
   60		}
   61	
   62	}

























































2016-04-29 00:34                ErrorHandler.java                 Page 1


    1	
    2	/*Name: Gautham Brahma Ponnaganti.
    3	 *Course No.: CS5323
    4	 *Assignment title:OS Project PHASE II
    5	 *Date:4-28-2016
    6	 *Global Variables:
    7	 *-errorCode: This can be set by a piece of code where the error occurs and later when the error handler class 
    8	 *calls this code it can keep track of which error by using this variable.
    9	 *-  
   10	 *
   11	 *Brief description: This is the error handler subsystem which will trap errors in other subsystems. Then it will check the 
   12	 *error code with custom error class and pull out the error number and custom error message and display the 
   13	 *exception occurred in user readable format
   14	 *
   15	 *Changes in PhaseII:
   16	 *Added new exceptions which arise due to reading of new file format when loading to disk and multiprogramming
   17	 *and Page replacement.
   18	 *
   19	 *Changes in PhaseIII:None
   20	 */
   21	import java.io.FileWriter;
   22	import java.io.IOException;
   23	
   24	public class ErrorHandler {
   25	
   26		public void errorhandler(int e) {
   27		String errorMessage = null;
   28		int jobID = 0;
   29		errorCode = e;
   30		errorMessage = getProperty(String.valueOf(errorCode));
   31		jobID = ErrorHandler.getJobID();
   32		try {
   33		String filename = "progressFile.txt";
   34		FileWriter fw = new FileWriter(filename, true);
   35		fw.write("\n");
   36		if (errorCode > 50) {
   37		fw.write("**WARNING: ");
   38		} else {
   39		fw.write("**ERROR: ");
   40		}
   41		fw.write("JOBID(DEC):" + jobID + " Code:" + errorCode + " ");
   42		fw.write("Description:" + errorMessage + "\n");
   43		fw.write("------------------------------------------------------");
   44		fw.close();
   45		} catch (IOException e1) {
   46		e1.printStackTrace();
   47		}
   48		}
   49	
   50		/*
   51		 * This is to notify the user if an error in system which is not specified
   52		 * below occurs
   53		 */
   54		public String HandleError(int exception) {
   55		errorhandler(exception);
   56		if (exception > 50)







2016-04-29 00:34                ErrorHandler.java                 Page 2


   57			return "Warning";
   58		else
   59			return "Error";
   60		}
   61	
   62		public static final int SYSTEM_ERROR = 999;
   63	
   64		/* IO related errors */
   65		public static final int FILE_NOT_FOUND = 2;
   66		public static final int INVALID_USER_INPUT = 3;
   67		public static final int UNABLE_TO_CREATE_FILE = 4;
   68	
   69		/* Loader related errors */
   70		public static final int ILLEGAL_CHAR = 5;
   71		public static final int INVALID_TRACE_FLAG = 6;
   72		public static final int PROGRAM_SIZE_TOO_LARGE = 7;
   73	
   74		/* Memory related exceptions */
   75		public static final int ADDRESS_OUT_OF_RANGE = 8;
   76	
   77		/* Arithmetic exceptions */
   78		public static final int DIVIDE_BY_ZERO = 9;
   79		public static final int INPUT_SIZE_OVERFLOW = 10;
   80	
   81		/* MISC */
   82		public static final int ILLEGAL_BATCH_FORMAT = 11;
   83		public static final int MISSING_PROGRAM = 12;
   84		public static final int MISSING_JOB_TAG = 13;
   85		public static final int TRACE_MISSING = 14;
   86		public static final int MISSING_DATA = 15;
   87		public static final int NULL_JOB = 16;
   88		public static final int INSUFFICIENT_OUTPUT_SPACE = 17;
   89		public static final int ARTHEMATIC_ERROR = 18;
   90		public static final int OUT_OF_BOUNDS = 19;
   91		public static final int IO_EXCEPTION = 20;
   92		public static final int NULL_POINTER = 21;
   93		public static final int SUSPECTED_INFINITE_JOB = 22;
   94		public static final int INVALID_OPCODE = 23;
   95	
   96		/* Warnings */
   97		public static final int MISSING_FIN = 51;
   98		public static final int DOUBLE_DATA = 52;
   99		public static final int MISSING_DATA_TAG = 53;
  100	
  101		private int errorCode;
  102		public static int JobID;
  103	
  104		public void customException(int msg) {
  105		this.errorCode = msg;
  106		}
  107	
  108		public int getErrorCode() {
  109		return errorCode;
  110		}
  111	
  112		public static void setJobID(int jobID) {







2016-04-29 00:34                ErrorHandler.java                 Page 3


  113		JobID = jobID;
  114		}
  115	
  116		public static int getJobID() {
  117		return JobID;
  118		}
  119	
  120		public static String getProperty(String errorCode) {
  121		String errorMessage = null;
  122		if (errorCode.equals("2")) {
  123		errorMessage = "The file name you entered does not exist.";
  124		} else if (errorCode.equals("5")) {
  125		errorMessage = "Illegal Batch Character.";
  126		} else if (errorCode.equals("3")) {
  127		errorMessage = "Invalid input. The input entered must be hex number.";
  128		} else if (errorCode.equals("6")) {
  129		errorMessage = "Invalid Trace flag.";
  130		} else if (errorCode.equals("7")) {
  131		errorMessage = "Program Size too large.";
  132		} else if (errorCode.equals("8")) {
  133		errorMessage = "Address out of range. The address referenced by the program counter must be less than the size of the memory.";
  134		} else if (errorCode.equals("9")) {
  135		errorMessage = "Attempt to divide by zero.";
  136		} else if (errorCode.equals("4")) {
  137		errorMessage = "Unable to create file";
  138		} else if (errorCode.equals("10")) {
  139		errorMessage = "Buffer overflow.";
  140		} else if (errorCode.equals("11")) {
  141		errorMessage = "Illegal batch format";
  142		} else if (errorCode.equals("12")) {
  143		errorMessage = "Missing Program";
  144		} else if (errorCode.equals("13")) {
  145		errorMessage = "Missing Job";
  146		} else if (errorCode.equals("14")) {
  147		errorMessage = "Trace Bit Missing";
  148		} else if (errorCode.equals("15")) {
  149		errorMessage = "MISSING DATA";
  150		} else if (errorCode.equals("16")) {
  151		errorMessage = "NULL JOB";
  152		} else if (errorCode.equals("17")) {
  153		errorMessage = "Insufficient Output Space";
  154		} else if (errorCode.equals("18")) {
  155		errorMessage = "Problem with number conversion.";
  156		} else if (errorCode.equals("19")) {
  157		errorMessage = "Out of Bounds";
  158		} else if (errorCode.equals("20")) {
  159		errorMessage = "IO Exception";
  160		} else if (errorCode.equals("21")) {
  161		errorMessage = "Null pointer Exception";
  162		} else if (errorCode.equals("22")) {
  163		errorMessage = "Suspected Infinite Job";
  164		} else if (errorCode.equals("23")) {
  165		errorMessage = "Invalid Opcode";
  166		} else if (errorCode.equals("51")) {
  167		errorMessage = "MISSING **FIN";
  168		} else if (errorCode.equals("52")) {







2016-04-29 00:34                ErrorHandler.java                 Page 4


  169		errorMessage = "Double **DATA";
  170		} else if (errorCode.equals("53")) {
  171		errorMessage = "MISSING **DATA";
  172		} else if (errorCode.equals("999")) {
  173		errorMessage = "System Error";
  174		}
  175		return errorMessage;
  176		}
  177	}






















































2016-04-29 00:34                   Loader.java                    Page 1


    1	/*Name: Gautham Brahma Ponnaganti.
    2	 *Course No.: CS5323
    3	 *Assignment title:OS Project PHASE II
    4	 *Date:4-28-2016
    5	 *Global Variables:
    6	 *-JobID: Used to keep track of job. It will always be 1 in this case because there is no multiprogramming and we give
    7	 *only one job as input once. 
    8	 *-buffer: Used for block transfer operation.
    9	 *-memory: used to reference memory so that it can load user programs in the memory and call CPU for execution
   10	 *-errorHandler: This is used to call the error handler because it can be used in case an error occurs
   11	 *-_ProgramPagesOnDisk,_DataPagesOnDisk,_OutputPagesOnDisk:used to keep track of the pages in memory.
   12	 *-NOLITB:used to know the end of the file and hence know that the file ended before hand.
   13	 *-executionEnded:used to keep track of the end of the execution of the last job.
   14	 *-Locus:used to keep track of where in the test file we currently are.This is used for error Handling.
   15	 *
   16	 *
   17	 *Brief description: This is used to do RD and WR operations which involves memory and console as CPU would 
   18	 *not be directly associated with these operations
   19	 *
   20	 *Changes in Phase II: We are changing the was of taking input and loading in the memory from file and load it into disk
   21	 *first instead of memory. Pages are created here and are put in the memory locations. whenever a job execution completes
   22	 *the control will branch back to here from which we will load into the disk space created.
   23	 *
   24	 *Changes in PhaseIII:None
   25	 */
   26	
   27	/*startAddress,Location,TraceFlag,Length are decoded to decimal values because they are easy to manage. The will be converted to 
   28	 hexadecimal values whenever necessary*/
   29	
   30	import java.io.File;
   31	import java.io.FileWriter;
   32	import java.io.IOException;
   33	import java.io.RandomAccessFile;
   34	import java.math.BigInteger;
   35	import java.util.ArrayList;
   36	import java.util.LinkedList;
   37	
   38	public class Loader {
   39	
   40		private int jobID = 0;
   41		String Status = "";
   42		int currentLine = 0;
   43		private Memory memory = new Memory();
   44		private Disk disk = new Disk();
   45		Scheduler scheduler = new Scheduler();
   46		ErrorHandler errorHandler = new ErrorHandler();
   47		public int pagesNeeded = 0, outputLines = 0;
   48		long currentFilePointer;
   49		String StringBuilder;
   50		ArrayList<String> PageBuilder = new ArrayList<String>();
   51		int pageEntry = 0;
   52		ArrayList<String> MetaData = new ArrayList<String>();
   53		int pageEntryCheckPoint;
   54		long FilePointerOfLastModule;
   55		boolean stopReadingTheCurrentJob = false;
   56		LinkedList<PCB> ListOfPCB = new LinkedList<PCB>();







2016-04-29 00:34                   Loader.java                    Page 2


   57		PCB pcb;
   58		ArrayList<String> _ProgramPagesOnDisk = new ArrayList<String>();
   59		ArrayList<String> _DataPagesOnDisk = new ArrayList<String>();
   60		ArrayList<String> _OutputPagesOnDisk = new ArrayList<String>();
   61		public static String[] diskAvailability = new String[256];
   62		public static int emptyPagesOnDisk = 255;
   63		public static boolean fileEndedExecuteAnyways = false;
   64		/* number of lines in test batch */
   65		public int NOLITB;
   66		public static int NOJITB;
   67	
   68		public static boolean executionEnded = false;
   69	
   70		/*
   71		 * locus defines the current point with in each job where the execution is
   72		 * happening it can be the following JOB,
   73		 * JOB_PAYLOAD_START,JOB_PAYLOAD,JOB_PAYLOAD_END,DATA,DATA_PAYLOAD,FIN
   74		 */
   75		public String locus = "FIN";
   76	
   77		/* This method will take value in hexadecimal and return a binary value */
   78		public String HEXBIN(String hexValue) {
   79		String value = new BigInteger(hexValue, 16).toString(2);
   80		return String.format("%32s", value).replace(" ", "0");
   81		}
   82	
   83		public static int getHolesNo() {
   84		String currentState = "true";
   85		int numberOfHoles = 0;
   86		for (int i = 0; i < diskAvailability.length; i++) {
   87		if (!diskAvailability[i].equals(currentState)) {
   88		currentState = diskAvailability[i];
   89		numberOfHoles++;
   90		}
   91		}
   92		return numberOfHoles / 2;
   93		}
   94	
   95		public static int getAvgHoleSize() {
   96		String currentState = "true";
   97		int numberOfHoles = 0;
   98		int holeSize = 0;
   99		for (int i = 0; i < diskAvailability.length; i++) {
  100		if (!diskAvailability[i].equals(currentState)) {
  101		currentState = diskAvailability[i];
  102		numberOfHoles++;
  103		}
  104		if (diskAvailability[i].equals("false")) {
  105		holeSize++;
  106		}
  107		}
  108		return holeSize / numberOfHoles;
  109		}
  110	
  111		public static int getPercentage() {
  112		int occSize = 0;







2016-04-29 00:34                   Loader.java                    Page 3


  113		for (int i = 0; i < diskAvailability.length; i++) {
  114		if (diskAvailability[i].equals("true")) {
  115		occSize++;
  116		}
  117		}
  118		return (occSize * 100) / 256;
  119		}
  120	
  121		public void loader(File fileName) {
  122		RandomAccessFile dataFromFile = null;
  123		String data = null;
  124		createProgressFile();
  125		int tempPointer = 0;
  126		int tempPointer2 = 0;
  127		int startAddress = 0, Location = 0, TraceFlag = 0, Length;
  128		try {
  129		// initialize the page table
  130		memory.initializePageTable("i");
  131		disk.intitalizePageTable();
  132		/*
  133		 * Initializing disk availability.By default all of disk is available
  134		 */
  135		for (int i = 0; i < diskAvailability.length; i++) {
  136		diskAvailability[i] = "true";
  137		}
  138		dataFromFile = new RandomAccessFile(fileName, "r");
  139		NOJITB++;
  140		while ((data = dataFromFile.readLine()) != null) {
  141		NOLITB++;
  142		if (data.trim().contains("**JOB")) {
  143		if (tempPointer2 - tempPointer > 2) {
  144		NOJITB++;
  145		}
  146		tempPointer = tempPointer2;
  147		}
  148		tempPointer2++;
  149		}
  150	
  151		// open the input file in read mode.
  152		dataFromFile = new RandomAccessFile(fileName, "r");
  153		while ((data = dataFromFile.readLine()) != null) {
  154		/* Making sure that the data doesn't have unwanted spaces */
  155		data = data.trim();
  156		currentLine++;
  157		currentFilePointer = dataFromFile.getFilePointer();
  158		if (data.startsWith("**")) {
  159		String commands[] = data.split("\\s+");
  160		if (commands[0].equals("**JOB")) {
  161		pageEntryCheckPoint = pageEntry;
  162		stopReadingTheCurrentJob = false;
  163		if (!locus.equals("FIN")) {
  164		ErrorHandler.setJobID(jobID);
  165		Status = errorHandler.HandleError(ErrorHandler.MISSING_FIN);
  166		HandleWarning(ErrorHandler.MISSING_FIN);
  167		}
  168		/* job */







2016-04-29 00:34                   Loader.java                    Page 4


  169		jobID++;
  170		pcb = new PCB();
  171		_ProgramPagesOnDisk.clear();
  172		_DataPagesOnDisk.clear();
  173		_OutputPagesOnDisk.clear();
  174		pcb.jobID = jobID;
  175		locus = "JOB";
  176	
  177		pagesNeeded = Integer.parseInt(commands[1], 16);
  178		/*
  179		 * Number of pages needed for output equals number of output lines
  180		 */
  181		if ((Integer.parseInt(commands[2], 16) % 4) == 0) {
  182		outputLines = (Integer.parseInt(commands[2], 16) / 4);
  183		} else {
  184		outputLines = (Integer.parseInt(commands[2], 16) / 4) + 1;
  185		}
  186		/*
  187		 * If we run out of disk space in the middle of read we can use this to get
  188		 * back to the start of the job module
  189		 */
  190		FilePointerOfLastModule = currentFilePointer;
  191		if ((pagesNeeded + outputLines) + 1 > emptyPagesOnDisk) {
  192		TimeToCallSheduler();
  193		} else {
  194		pageEntry = 0;
  195		}
  196		StringBuilder = "JobID:" + Integer.toString(jobID);
  197		MetaData.add(StringBuilder);
  198		StringBuilder = "";
  199		} else if (commands[0].equals("**DATA")) {
  200		if (!stopReadingTheCurrentJob) {
  201		if (locus.equals("DATA")) {
  202		ErrorHandler.setJobID(jobID);
  203		errorHandler.HandleError(ErrorHandler.DOUBLE_DATA);
  204		HandleWarning(ErrorHandler.DOUBLE_DATA);
  205		}
  206		locus = "DATA";
  207		if (locus.equals("JOB")) {
  208		ErrorHandler.setJobID(jobID);
  209		errorHandler.HandleError(ErrorHandler.NULL_JOB);
  210		HandleError(ErrorHandler.NULL_JOB);
  211		}
  212		/*
  213		 * To write to disk when page is not full but no more instructions
  214		 */
  215		if (PageBuilder.size() > 0) {
  216		for (int k = PageBuilder.size(); k < 16; k++) {
  217		PageBuilder.add("00000000");
  218		StringBuilder += "00000000" + "-";
  219		}
  220		while (pageEntry < 255) {
  221		if (diskAvailability[pageEntry].equals("true")) {
  222		diskAvailability[pageEntry] = "false";
  223		break;
  224		} else {







2016-04-29 00:34                   Loader.java                    Page 5


  225		if (pageEntry < 255)
  226			pageEntry++;
  227		else {
  228		ErrorHandler.setJobID(jobID);
  229		errorHandler.HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  230		HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  231		}
  232		}
  233		}
  234		writePageToDisk(PageBuilder, pageEntry);
  235		_ProgramPagesOnDisk.add(Integer.toString(pageEntry));
  236		emptyPagesOnDisk--;
  237		MetaData.add("PageNo:" + pageEntry + "--" + StringBuilder);
  238		StringBuilder = "";
  239		PageBuilder.clear();
  240		if (pageEntry < 255)
  241			pageEntry++;
  242		}
  243		MetaData.add("**DATA");
  244		}
  245		} else if (commands[0].equals("**FIN")) {
  246		if (!stopReadingTheCurrentJob) {
  247		locus = "FIN";
  248		if (locus.equals("JOB_PAYLOAD_END") || locus.equals("DATA")) {
  249		ErrorHandler.setJobID(jobID);
  250		errorHandler.HandleError(ErrorHandler.MISSING_DATA);
  251		HandleError(ErrorHandler.MISSING_DATA);
  252		}
  253		if (PageBuilder.size() > 0) {
  254		/*
  255		 * To write to disk when page is not full but no more Data
  256		 */
  257		for (int k = PageBuilder.size(); k < 16; k++) {
  258		PageBuilder.add("00000000");
  259		StringBuilder += "00000000" + "-";
  260		}
  261		while (pageEntry < 255) {
  262		if (diskAvailability[pageEntry].equals("true")) {
  263		diskAvailability[pageEntry] = "false";
  264		break;
  265		} else {
  266		if (pageEntry < 255)
  267			pageEntry++;
  268		else {
  269		ErrorHandler.setJobID(jobID);
  270		errorHandler.HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  271		HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  272		}
  273		}
  274		}
  275		writePageToDisk(PageBuilder, pageEntry);
  276		_DataPagesOnDisk.add(Integer.toString(pageEntry));
  277		emptyPagesOnDisk--;
  278		MetaData.add("PageNo:" + pageEntry + "--" + StringBuilder);
  279		StringBuilder = "";
  280		PageBuilder.clear();







2016-04-29 00:34                   Loader.java                    Page 6


  281		if (pageEntry < 255)
  282			pageEntry++;
  283		}
  284		pageEntry = 0;
  285		if (outputLines < emptyPagesOnDisk) {
  286		while (outputLines > 0) {
  287		if (outputLines > 0 && pageEntry >= 255) {
  288		/* Break the infinite loop */
  289		break;
  290		}
  291		while (pageEntry < 255) {
  292		if (diskAvailability[pageEntry].equals("true")) {
  293		diskAvailability[pageEntry] = "false";
  294		_OutputPagesOnDisk.add(Integer.toString(pageEntry));
  295		outputLines--;
  296		emptyPagesOnDisk--;
  297		break;
  298		} else {
  299		if (pageEntry < 255)
  300			pageEntry++;
  301		else
  302			break;
  303		}
  304		}
  305		}
  306		}
  307		pcb.ProgramPagesOnDisk = new String[_ProgramPagesOnDisk.size()];
  308		_ProgramPagesOnDisk.toArray(pcb.ProgramPagesOnDisk);
  309		pcb.DataPagesOnDisk = new String[_DataPagesOnDisk.size()];
  310		_DataPagesOnDisk.toArray(pcb.DataPagesOnDisk);
  311		pcb.OutputPagesOnDisk = new String[_OutputPagesOnDisk.size()];
  312		_OutputPagesOnDisk.toArray(pcb.OutputPagesOnDisk);
  313		pcb.pageFaultBits = new ArrayList<String>();
  314		for (int i = 0; i < pcb.ProgramPagesOnDisk.length; i++) {
  315		pcb.pageFaultBits.add("000");
  316		}
  317		pcb.startedWritingTrace = false;
  318		pcb.numberOfChancesCPU = 0;
  319		try {
  320		FileWriter statusWrite2 = new FileWriter("progressFile.txt", true);
  321		statusWrite2.write("\n");
  322		statusWrite2
  323				.write(String.format("%-40s %-15s", "JobID loaded(DEC):", jobID));
  324		statusWrite2.write("\n");
  325		statusWrite2.write(String.format("%-40s %-15s",
  326				"Clock value during load(Decimal):", CPU.loadtracker));
  327		statusWrite2.write("\n");
  328		statusWrite2
  329				.write("------------------------------------------------------");
  330		statusWrite2.close();
  331		} catch (IOException e) {
  332		System.out.print("");
  333		}
  334		ListOfPCB.add(pcb);
  335		if (currentLine == NOLITB) {
  336		fileEndedExecuteAnyways = true;







2016-04-29 00:34                   Loader.java                    Page 7


  337		TimeToCallSheduler();
  338		}
  339		MetaData.add("**FIN");
  340		}
  341		}
  342		} else {
  343		if (!stopReadingTheCurrentJob) {
  344		/* Check Data for illegal characters */
  345		checkInputData(data);
  346		/* Where we get an empty line the read should end */
  347		if (data.length() == 0) {
  348		}
  349		/*
  350		 * Data identified as First Record if it's length is 5 bits
  351		 */
  352		if (data.length() == 5) {
  353		if (locus.equals("FIN")) {
  354		ErrorHandler.setJobID(jobID);
  355		errorHandler.HandleError(ErrorHandler.MISSING_JOB_TAG);
  356		HandleError(ErrorHandler.MISSING_JOB_TAG);
  357		}
  358		locus = "JOB_PAYLOAD_START";
  359		Location = Integer.parseInt(data.substring(0, 2), 16);
  360		pcb.PC = Location;
  361		Length = Integer.parseInt(data.substring(3, 5), 16);
  362		if (Length > 255) {
  363		ErrorHandler.setJobID(jobID);
  364		errorHandler.HandleError(ErrorHandler.PROGRAM_SIZE_TOO_LARGE);
  365		HandleError(ErrorHandler.PROGRAM_SIZE_TOO_LARGE);
  366		}
  367		}
  368		/*
  369		 * Data identified as Last Record if it's length is 4 bits
  370		 */
  371		if (data.length() == 4) {
  372		if (locus.equals("JOB_PAYLOAD_START")) {
  373		ErrorHandler.setJobID(jobID);
  374		errorHandler.HandleError(ErrorHandler.MISSING_PROGRAM);
  375		HandleError(ErrorHandler.MISSING_PROGRAM);
  376		} else {
  377		locus = "JOB_PAYLOAD_END";
  378		}
  379		startAddress = Integer.parseInt(data.substring(0, 2), 16);
  380		if (startAddress > 255 || startAddress < 0) {
  381		// err.setJobID(jobID);
  382		ErrorHandler.setJobID(jobID);
  383		errorHandler.HandleError(ErrorHandler.ADDRESS_OUT_OF_RANGE);
  384		}
  385		TraceFlag = Integer.parseInt(data.substring(3, 4));
  386		pcb.traceFlag = TraceFlag;
  387		if (TraceFlag != 0 && TraceFlag != 1) {
  388		ErrorHandler.setJobID(jobID);
  389		errorHandler.HandleError(ErrorHandler.INVALID_TRACE_FLAG);
  390		HandleError(ErrorHandler.INVALID_TRACE_FLAG);
  391		}
  392		if (disk.spaceLeft > 0) {







2016-04-29 00:34                   Loader.java                    Page 8


  393	
  394		}
  395		}
  396		/* Condition to handle null trace */
  397		if (data.length() == 2) {
  398		if (locus.equals("JOB_PAYLOAD")) {
  399		ErrorHandler.setJobID(jobID);
  400		}
  401		}
  402		/*
  403		 * Data identified as Data Record if it's length is 32 bits
  404		 */
  405		if (data.length() == 32 || data.length() == 8 || data.length() == 16
  406				|| data.length() == 24) {
  407	
  408		if (locus.equals("DATA") || locus.equals("DATA_PAYLOAD")) {
  409		locus = "DATA_PAYLOAD";
  410		} else if (locus.equals("JOB_PAYLOAD_START")
  411				|| locus.equals("JOB_PAYLOAD")) {
  412		locus = "JOB_PAYLOAD";
  413		} else if (locus.equals("JOB_PAYLOAD_END") && data.length() == 32) {
  414		ErrorHandler.setJobID(jobID);
  415		errorHandler.HandleError(ErrorHandler.MISSING_DATA_TAG);
  416		/*
  417		 * We append the data tag so before we do we write instructions to disk
  418		 */
  419		if (PageBuilder.size() > 0) {
  420		for (int k = PageBuilder.size(); k < 16; k++) {
  421		PageBuilder.add("00000000");
  422		StringBuilder += "00000000" + "-";
  423		}
  424		while (pageEntry < 255) {
  425		if (diskAvailability[pageEntry].equals("true")) {
  426		diskAvailability[pageEntry] = "false";
  427		break;
  428		} else {
  429		if (pageEntry < 255)
  430			pageEntry++;
  431		else {
  432		ErrorHandler.setJobID(jobID);
  433		errorHandler.HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  434		HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  435		}
  436		}
  437		}
  438		writePageToDisk(PageBuilder, pageEntry);
  439		_ProgramPagesOnDisk.add(Integer.toString(pageEntry));
  440		emptyPagesOnDisk--;
  441		MetaData.add("PageNo:" + pageEntry + "--" + StringBuilder);
  442		StringBuilder = "";
  443		PageBuilder.clear();
  444		if (pageEntry < 255)
  445			pageEntry++;
  446		}
  447		HandleWarning(ErrorHandler.MISSING_DATA_TAG);
  448		} else {







2016-04-29 00:34                   Loader.java                    Page 9


  449		ErrorHandler.setJobID(jobID);
  450		errorHandler.HandleError(ErrorHandler.ILLEGAL_BATCH_FORMAT);
  451		HandleError(ErrorHandler.ILLEGAL_BATCH_FORMAT);
  452		}
  453		for (int i = 0; i < data.length(); i = i + 8) {
  454		PageBuilder.add(data.substring(i, i + 8));
  455		StringBuilder += data.substring(i, i + 8) + "-";
  456		if (PageBuilder.size() > 15) {
  457		while (pageEntry < 255) {
  458		if (diskAvailability[pageEntry].equals("true")) {
  459		diskAvailability[pageEntry] = "false";
  460		break;
  461		} else {
  462		if (pageEntry < 255)
  463			pageEntry++;
  464		else {
  465		ErrorHandler.setJobID(jobID);
  466		errorHandler.HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  467		HandleError(ErrorHandler.INSUFFICIENT_OUTPUT_SPACE);
  468		}
  469		}
  470		}
  471		writePageToDisk(PageBuilder, pageEntry);
  472		emptyPagesOnDisk--;
  473		if (locus.equals("JOB_PAYLOAD")) {
  474		_ProgramPagesOnDisk.add(Integer.toString(pageEntry));
  475		}
  476		if (locus.equals("DATA_PAYLOAD")) {
  477		_DataPagesOnDisk.add(Integer.toString(pageEntry));
  478		}
  479		MetaData.add("PageNo:" + pageEntry + "--" + StringBuilder);
  480		StringBuilder = "";
  481		PageBuilder.clear();
  482		if (pageEntry < 255)
  483			pageEntry++;
  484		}
  485		}
  486		}
  487		}
  488		}
  489		}
  490		} catch (Exception e) {
  491		e.printStackTrace();
  492		}
  493	
  494		}
  495	
  496		private void createProgressFile() {
  497		try {
  498		String filename = "progressFile.txt";
  499		// TODO: remove false
  500		FileWriter fw = new FileWriter(filename);
  501		fw.close();
  502		} catch (IOException e) {
  503		e.printStackTrace();
  504		}







2016-04-29 00:34                   Loader.java                   Page 10


  505		}
  506	
  507		private void TimeToCallSheduler() {
  508		scheduler.manageDiskReference(disk, ListOfPCB);
  509		if ((pagesNeeded + outputLines) + 1 > emptyPagesOnDisk) {
  510		/*
  511		 * new process is bigger than the terminated one. more processes need to go
  512		 */
  513		TimeToCallSheduler();
  514		} else {
  515		pageEntry = 0;
  516		}
  517		}
  518	
  519		private void HandleError(int ErrorCode) {
  520		/*
  521		 * We will make the diskAvailability of the current job that has error as
  522		 * true so that these locations are available to the next jobs and the error
  523		 * job gets overwritten
  524		 */
  525		pageEntry = pageEntryCheckPoint;
  526		PageBuilder.clear();
  527		int index = 0;
  528		/* delete this job from metadata */
  529		for (int i = 0; i < MetaData.size(); i++) {
  530		if (MetaData.get(i).contains("JobID:" + jobID)) {
  531		index = i;
  532		}
  533		}
  534		int length = MetaData.size();
  535		if (index != 0) {
  536		for (int i = index; i < length; i++) {
  537		MetaData.remove(index);
  538		}
  539		}
  540		/* stop reading rest of the job and start from the start of next job */
  541		stopReadingTheCurrentJob = true;
  542		locus = "FIN";
  543		}
  544	
  545		private void HandleWarning(int warningCode) {
  546		if (warningCode == ErrorHandler.MISSING_FIN) {
  547		StringBuilder = "**FIN";
  548		MetaData.add(StringBuilder);
  549		StringBuilder = "";
  550		}
  551		if (warningCode == ErrorHandler.DOUBLE_DATA) {
  552		MetaData.remove(MetaData.size() - 1);
  553		}
  554		if (warningCode == ErrorHandler.MISSING_DATA_TAG) {
  555		MetaData.add("**DATA");
  556		locus = "DATA";
  557		}
  558		}
  559	
  560		private void writePageToDisk(ArrayList<String> pageBuilder2,







2016-04-29 00:34                   Loader.java                   Page 11


  561				int pageEntry2) {
  562		disk.writeToDisk(pageBuilder2, pageEntry2);
  563		}
  564	
  565		/*
  566		 * This is to check if the given values are deviating from hex integers.
  567		 * This will handle the invalid user input exception given in the
  568		 * specification. ASCII characters 64 to 71 represent digits 0 to 9 and 96
  569		 * to 103 represent a to f and 32 represents space
  570		 */
  571		private void checkInputData(String data) {
  572		for (char input : data.toCharArray()) {
  573		int code = (int) input;
  574		if ((code > 47 && code < 58) || (code > 64 && code < 71)
  575				|| (code > 96 && code < 103)
  576				|| code == 32 && data.split("\\s+").length == 2) {
  577		continue;
  578		}
  579		ErrorHandler.setJobID(jobID);
  580		errorHandler.HandleError(ErrorHandler.ILLEGAL_CHAR);
  581		HandleError(ErrorHandler.ILLEGAL_CHAR);
  582		}
  583	
  584		}
  585	
  586		public Memory getMemory() {
  587		return memory;
  588		}
  589	
  590	}

































2016-04-29 00:34                   Memory.java                    Page 1


    1	
    2	/*-MEM: This is used as a data structure to simulate physical memory.
    3	 * 
    4	 *
    5	 *Brief description: This is used to simulate memory. 
    6	 *
    7	 *Changes in phase II:In this phase we will add a page table in the memory and 
    8	 *all the address references to the memory will be virtual which will be converted into 
    9	 *physical before we access the page table.
   10	 *
   11	 *Changes in Phase III:None
   12	 */
   13	import java.io.FileWriter;
   14	
   15	public class Memory {
   16		public static String[] Mem = new String[256];
   17		static int[] pageTable = new int[16];
   18	
   19		/*
   20		 * x specifies read or write or dump,y is for memory address and z is the
   21		 * variable to be written or read into
   22		 */
   23		public void Mem(String x, int y, String[] z) {
   24		/*
   25		 * Initializing memory as an array of strings size 256 as it is given that
   26		 * array should be indexed from 00 to FF .The incoming indexes will be in
   27		 * hex values which we will convert them to decimal indexes
   28		 */
   29		/* translating physical address to virtual address */
   30		y = convertVirtualAddressToPhysical(y);
   31		if (y > 252) {
   32		}
   33		/*
   34		 * When we get an instruction to write we start from the location(which is
   35		 * y) and write to the next 4 memory locations
   36		 */
   37		else if (x.equals("WRIT")) {
   38		for (int i = y, k = 0; i < y + 4; i++, k++) {
   39		/*
   40		 * writing contents of z to 4 contiguous memory location starting from y
   41		 */
   42		Mem[i] = z[k];
   43		}
   44		} else if (x.equals("DUMP")) {
   45		try {
   46		String filename = "progressFile.txt";
   47		FileWriter fw = new FileWriter(filename, true);
   48		// fw.write("Memory Dump(in HEX): ");
   49		for (int i = 0; i < Mem.length; i++) {
   50		CPU.memoryDumpArray.add(Mem[i]);
   51	
   52		}
   53		fw.close();
   54		} catch (Exception e) {
   55		e.printStackTrace();
   56		}







2016-04-29 00:34                   Memory.java                    Page 2


   57		}
   58		}
   59	
   60		public int convertVirtualAddressToPhysical(int y) {
   61		int virtualAddressInDecimal = y;
   62		String virtualAddressIndex = String.format("%02X", virtualAddressInDecimal);
   63		/*
   64		 * Page Table being an array is indexed in decimal. The hex value needs to
   65		 * be converted to decimal
   66		 */
   67		String PageTableIndex = virtualAddressIndex.substring(0, 1);
   68		String Offset = virtualAddressIndex.substring(1, 2);
   69		int PageTableIndexDec = Integer.parseInt(PageTableIndex, 16);
   70		int FrameNumber = pageTable[PageTableIndexDec];
   71	
   72		String FrameNumberHex = String.format("%01X", FrameNumber);
   73		String PhysicalAddress = FrameNumberHex + Offset;
   74		return Integer.parseInt(PhysicalAddress, 16);
   75		}
   76	
   77		/*
   78		 * we are overloading Mem method because we are expecting a different return
   79		 * type from each of these methods and because we are writing the content
   80		 * from register which is a string and not content of a buffer which is a
   81		 * string array
   82		 */
   83		public String Mem(String x, int y, String z) {
   84		y = convertVirtualAddressToPhysical(y);
   85		if (x.equals("READ")) {
   86		z = Mem[y];
   87		} else if (x.equals("WRIT")) {
   88		/* writing contents of register z to memory location y */
   89		if (z.length() < 8) {
   90		for (int k = z.length(); k < 8; k++) {
   91		z = "0" + z;
   92		}
   93		}
   94		Mem[y] = z;
   95		}
   96		if (z == null) {
   97		z = "00000000";
   98		}
   99		return z;
  100		}
  101	
  102		/*
  103		 * This method will be accessed by the loader to initialize the page table
  104		 */
  105		public void initializePageTable(String index) {
  106		if (index.equals("i")) {
  107		for (int i = 0; i < pageTable.length; i++) {
  108		pageTable[i] = i;
  109		}
  110		} else if (index.equals("15-i")) {
  111		for (int i = 0; i < pageTable.length; i++) {
  112		pageTable[i] = 15 - i;







2016-04-29 00:34                   Memory.java                    Page 3


  113		}
  114		}
  115		}
  116	
  117		/* This is for pageTransfer */
  118		public void writeToMemory(String Action, int pageNumber,
  119				String[] PageToWrite) {
  120		if (Action.equals("WRIT") || (pageNumber * 16) < 255) {
  121		for (int i = pageNumber * 16, j = 0; i < (pageNumber * 16) + 16; i++, j++) {
  122		Mem[i] = PageToWrite[j];
  123		}
  124		}
  125		}
  126	
  127	}
















































2016-04-25 11:05                     PCB.java                     Page 1


    1	/*
    2	 *Brief description: This is data structure used to simulate a PCB in the system.It will be 
    3	 * be an aid in facilitating multiprogramming as we can save the state of the system into this
    4	 * data Structure when we want to context switch.
    5	 *
    6	 */
    7	import java.util.ArrayList;
    8	import java.util.LinkedList;
    9	
   10	public class PCB {
   11		public int PC;
   12		public String[] ProgramPagesOnDisk;
   13		public String[] DataPagesOnDisk;
   14		public String[] OutputPagesOnDisk;
   15		public String[] ProgramPagesOnMem;
   16		public String[] DataPagesOnMem;
   17		public String[] OutputPagesOnMem;
   18		public String[] registers;
   19		public String[] GeneralPurpouse;
   20		public ArrayList<String> PageTable;
   21		public int timeJobEnteredTheSystem;
   22		public int cumilativeTimeUsedByJob;
   23		public int jobID;
   24		public String diskAddressofCurrentRD;
   25		public String diskAddressofCurrentWR;
   26		public int timeOfCompletionOfIO;
   27		public int traceFlag;
   28		public String currentOperation;
   29		/*RFWT=Read from or write to*/
   30		public String AddressRFWT;
   31		public String resultOfReadOperation;
   32		public String resultOfWriteOperation;
   33		public int readPointer;
   34		public int writePointer;
   35		public String errorDescription;
   36		public ArrayList<String> pageFaultBits;
   37		public int pageFaultHandlingTime;
   38		public LinkedList<Object> SystemStatus=new LinkedList<Object>();
   39		public boolean startedWritingTrace;
   40		public int iotime;
   41		public int TimeQuantum;
   42		public int numberOfTurns;
   43		public int currentSubqueueLevel;
   44		public int numberOfChancesCPU;
   45	}


















2016-04-29 00:36                  Scheduler.java                  Page 1


    1	
    2	/*Global Variables:
    3	 * -Process/running/blocked/terminated Queue: These are list of PCB's necessary for maintaining various states
    4	 * of a process in multiprogramming.
    5	 * -PagesForProgram:Number of pages a program needs.
    6	 * -diskIndexToDeleteFrom, memIndexToDeleteFrom, processIndexToDeleteFrom:during the termination of a process we use
    7	 * these variables to deallocate the space allocated for them.
    8	 * -MemAvailability: used to keep track of the memory availability.
    9	 * 
   10	 * Brief Description:Scheduler is responsible for maintaining ready and blocked queue and it is also responsible for 
   11	 * creating PCB for jobs. It is responsible to handle whenever control branched back from the CPU by scheduling
   12	 * new processes or by terminating completed or error processes.
   13	 * 
   14	 * Changes in PhaseIII: Changed the scheduling algorithm from round robin to multilevel feedback queues
   15	 * */
   16	
   17	import java.util.ArrayList;
   18	import java.util.LinkedList;
   19	
   20	public class Scheduler {
   21		/** Task time limit for detecting infinite loop. */
   22		public static final int TIME_LIMIT = 1000;
   23	
   24		/**
   25		 * Current running process. This value must not be null when there is a job
   26		 * running in CPU.
   27		 */
   28	
   29		PCB pcb;
   30		Disk diskReference;
   31		Memory memory = new Memory();
   32		CPU cpu = new CPU();
   33		LinkedList<PCB> processQueue = new LinkedList<PCB>();
   34		LinkedList<PCB> readyQueue = new LinkedList<PCB>();
   35		LinkedList<PCB> runningQueue = new LinkedList<PCB>();
   36		LinkedList<PCB> BlockedQueue = new LinkedList<PCB>();
   37		LinkedList<PCB> TerminatedQueue = new LinkedList<PCB>();
   38		LinkedList<PCB> subQueue1 = new LinkedList<PCB>();
   39		LinkedList<PCB> subQueue2 = new LinkedList<PCB>();
   40		LinkedList<PCB> subQueue3 = new LinkedList<PCB>();
   41		LinkedList<PCB> subQueue4 = new LinkedList<PCB>();
   42		String[] PagesForProgram;
   43		ArrayList<String> _ProgramPagesOnMem = new ArrayList<String>();
   44		ArrayList<String> _DataPagesOnMem = new ArrayList<String>();
   45		ArrayList<String> _OutputPagesOnMem = new ArrayList<String>();
   46		public static ArrayList<Integer> contentOfSubqueue1 = new ArrayList<Integer>();
   47		public static ArrayList<Integer> contentOfSubqueue2 = new ArrayList<Integer>();
   48		public static ArrayList<Integer> contentOfSubqueue3 = new ArrayList<Integer>();
   49		public static ArrayList<Integer> contentOfSubqueue4 = new ArrayList<Integer>();
   50		int terminatedJobID = 0;
   51		/* By default all of the memory is available */
   52		String[] MemAvailability = {"true", "true", "true", "true", "true", "true",
   53				"true", "true", "true", "true", "true", "true", "true", "true",
   54				"true", "true"};
   55		int emptyPagesOnMem = 16;
   56		int PageIndex = 0;







2016-04-29 00:36                  Scheduler.java                  Page 2


   57		int diskIndexToDeleteFrom, memIndexToDeleteFrom, processIndexToDeleteFrom;
   58		String[] blockForMem = new String[16];
   59		int processQueSize = 0;
   60		int recursionCount = 0;
   61		boolean isRecursiveCall = false;
   62		boolean hasMore = true;
   63		int pagesNeeded = 0;
   64		boolean lastFewProcess = false;
   65		ErrorHandler err = new ErrorHandler();
   66		public static int allowedQuantum = 35;
   67		public static int allowedNumberOfTurns = 3;
   68		public static int subqueue1Size = 0;
   69		public static int subqueue2Size = 0;
   70		public static int subqueue3Size = 0;
   71		public static int subqueue4Size = 0;
   72		public static int matrixMetric = 0;
   73	
   74		public void manageDiskReference(Disk _disk, LinkedList<PCB> _listOfPCB) {
   75		diskReference = _disk;
   76		processQueue = _listOfPCB;
   77		loadToMemory();
   78		}
   79	
   80		private void loadToMemory() {
   81		for (int i = processQueSize; i < processQueue.size(); i++) {
   82		/* check the number of pages the program takes */
   83		pagesNeeded = processQueue.get(i).ProgramPagesOnDisk.length;
   84		if (pagesNeeded == 1) {
   85		pagesNeeded = 1;
   86		} else if ((pagesNeeded / 3) <= 2) {
   87		pagesNeeded = 2;
   88		} else {
   89		pagesNeeded = pagesNeeded / 3;
   90		}
   91		PagesForProgram = new String[pagesNeeded];
   92		try {
   93		for (int l = 0; l < pagesNeeded; l++) {
   94		PagesForProgram[l] = processQueue.get(i).ProgramPagesOnDisk[l];
   95		}
   96		} catch (ArrayIndexOutOfBoundsException e) {
   97		ErrorHandler.setJobID(processQueue.get(i).jobID);
   98		err.HandleError(ErrorHandler.OUT_OF_BOUNDS);
   99		processQueue.remove(i);
  100		break;
  101		}
  102		try {
  103		/* check if the program fits on the disk */
  104		if (PagesForProgram.length <= emptyPagesOnMem) {
  105		/*
  106		 * write the contents of the disk into the memory locations available
  107		 */
  108		writeDiskContentToMem(PagesForProgram,
  109				processQueue.get(i).ProgramPagesOnDisk.length,
  110				processQueue.get(i).jobID);
  111		processQueue.get(i).ProgramPagesOnMem = new String[_ProgramPagesOnMem
  112				.size()];







2016-04-29 00:36                  Scheduler.java                  Page 3


  113		_ProgramPagesOnMem.toArray(processQueue.get(i).ProgramPagesOnMem);
  114		_ProgramPagesOnMem.clear();
  115		processQueue.get(i).currentOperation = "NEW";
  116		/* Setting bit 0 as 1 indicating the page is in memory */
  117		try {
  118		for (int k = 0; k < PagesForProgram.length; k++) {
  119		processQueue.get(i).pageFaultBits.set(k,
  120				"1" + processQueue.get(i).pageFaultBits.get(k).substring(1, 3));
  121		}
  122		} catch (IndexOutOfBoundsException e) {
  123		ErrorHandler.setJobID(processQueue.get(i).jobID);
  124		err.HandleError(ErrorHandler.OUT_OF_BOUNDS);
  125		processQueue.remove(i);
  126		break;
  127		}
  128		processQueue.get(i).currentSubqueueLevel = 1;
  129		subQueue1.add(processQueue.get(i));
  130		}
  131		if (PagesForProgram.length > emptyPagesOnMem
  132				|| i == processQueue.size() - 1) {
  133		processQueSize = 0;
  134		if (subQueue1.size() > 0) {
  135		processQueSize = subQueue1.size();
  136		}
  137		if (subQueue2.size() > 0) {
  138		processQueSize += subQueue2.size();
  139		}
  140		if (subQueue3.size() > 0) {
  141		processQueSize += subQueue3.size();
  142		}
  143		if (subQueue4.size() > 0) {
  144		processQueSize += subQueue4.size();
  145		}
  146	
  147		cpu.setMemoryObject(memory);
  148		scheduleReadyProcesses();
  149	
  150		/*
  151		 * remove the disk and memory spaces allocated for terminated process and
  152		 * delete the terminated process from the process queue and branch back to
  153		 * loader.
  154		 */
  155	
  156		/* For Programs on disk */
  157		for (int j = 0; j < TerminatedQueue
  158				.getLast().ProgramPagesOnDisk.length; j++) {
  159		diskIndexToDeleteFrom = Integer
  160				.parseInt(TerminatedQueue.getLast().ProgramPagesOnDisk[j]);
  161		Loader.diskAvailability[diskIndexToDeleteFrom] = "true";
  162		Loader.emptyPagesOnDisk++;
  163		for (int k = diskIndexToDeleteFrom * 16; k < (diskIndexToDeleteFrom * 16)
  164				+ 16; k++) {
  165		diskReference.disk[k] = null;
  166		}
  167		}
  168	







2016-04-29 00:36                  Scheduler.java                  Page 4


  169		/* For data on disk */
  170		if (!(TerminatedQueue.getLast().currentOperation.equals("error")
  171				|| TerminatedQueue.getLast().errorDescription
  172						.equals("Missing Data"))) {
  173		for (int j = 0; j < TerminatedQueue.getLast().DataPagesOnDisk.length; j++) {
  174		diskIndexToDeleteFrom = Integer
  175				.parseInt(TerminatedQueue.getLast().DataPagesOnDisk[j]);
  176		Loader.diskAvailability[diskIndexToDeleteFrom] = "true";
  177		Loader.emptyPagesOnDisk++;
  178		for (int k = diskIndexToDeleteFrom * 16; k < (diskIndexToDeleteFrom * 16)
  179				+ 16; k++) {
  180		diskReference.disk[k] = null;
  181		}
  182		}
  183		}
  184		/* output space on disk */
  185		for (int j = 0; j < TerminatedQueue
  186				.getLast().OutputPagesOnDisk.length; j++) {
  187		diskIndexToDeleteFrom = Integer
  188				.parseInt(TerminatedQueue.getLast().OutputPagesOnDisk[j]);
  189		Loader.diskAvailability[diskIndexToDeleteFrom] = "true";
  190		Loader.emptyPagesOnDisk++;
  191		for (int k = diskIndexToDeleteFrom * 16; k < (diskIndexToDeleteFrom * 16)
  192				+ 16; k++) {
  193		diskReference.disk[k] = null;
  194		}
  195		}
  196		/* program on memory */
  197		for (int j = 0; j < TerminatedQueue
  198				.getLast().ProgramPagesOnMem.length; j++) {
  199		if (!TerminatedQueue.getLast().pageFaultBits.get(j).substring(0, 1)
  200				.equals("0")) {
  201		try {
  202		memIndexToDeleteFrom = Integer
  203				.parseInt(TerminatedQueue.getLast().ProgramPagesOnMem[j]);
  204		MemAvailability[memIndexToDeleteFrom] = "true";
  205		emptyPagesOnMem++;
  206		for (int k = memIndexToDeleteFrom * 16; k < (memIndexToDeleteFrom * 16)
  207				+ 16; k++) {
  208		Memory.Mem[k] = null;
  209		}
  210		} catch (NumberFormatException e) {
  211		ErrorHandler.setJobID(processQueue.get(i).jobID);
  212		err.HandleError(ErrorHandler.ARTHEMATIC_ERROR);
  213		processQueue.remove(i);
  214		break;
  215		}
  216	
  217		}
  218		}
  219	
  220		/* from process queue */
  221		terminatedJobID = TerminatedQueue.getLast().jobID;
  222		for (int j = 0; j < processQueue.size(); j++) {
  223		if (processQueue.get(j).jobID == terminatedJobID) {
  224		processIndexToDeleteFrom = j;







2016-04-29 00:36                  Scheduler.java                  Page 5


  225		break;
  226		}
  227		}
  228		processQueue.remove(processIndexToDeleteFrom);
  229		processQueSize--;
  230		break;
  231		}
  232		} catch (NullPointerException e) {
  233		ErrorHandler.setJobID(processQueue.get(i).jobID);
  234		err.HandleError(ErrorHandler.NULL_POINTER);
  235	
  236		for (int j = 0; j < processQueue.size(); j++) {
  237		if (processQueue.get(j).jobID == terminatedJobID) {
  238		processIndexToDeleteFrom = j;
  239		break;
  240		}
  241		}
  242		processQueue.remove(processIndexToDeleteFrom);
  243		break;
  244		}
  245		}
  246	
  247		if (Loader.fileEndedExecuteAnyways == true) {
  248	
  249		while (processQueue.size() > 0) {
  250		try {
  251		for (int i = processQueSize; i < processQueue.size(); i++) {
  252		/* check the number of pages the program takes */
  253		pagesNeeded = processQueue.get(i).ProgramPagesOnDisk.length;
  254		if (pagesNeeded == 1) {
  255		pagesNeeded = 1;
  256		} else if ((pagesNeeded / 3) <= 2) {
  257		pagesNeeded = 2;
  258		} else {
  259		pagesNeeded = pagesNeeded / 3;
  260		}
  261		PagesForProgram = new String[pagesNeeded];
  262		for (int l = 0; l < pagesNeeded; l++) {
  263		PagesForProgram[l] = processQueue.get(i).ProgramPagesOnDisk[l];
  264		}
  265		if (PagesForProgram.length <= emptyPagesOnMem && lastFewProcess == false) {
  266		/*
  267		 * write the contents of the disk into the memory locations available
  268		 */
  269		writeDiskContentToMem(PagesForProgram,
  270				processQueue.get(i).ProgramPagesOnDisk.length,
  271				processQueue.get(i).jobID);
  272		processQueue.get(i).ProgramPagesOnMem = new String[_ProgramPagesOnMem
  273				.size()];
  274		_ProgramPagesOnMem.toArray(processQueue.get(i).ProgramPagesOnMem);
  275		_ProgramPagesOnMem.clear();
  276		processQueue.get(i).currentOperation = "NEW";
  277		/*
  278		 * Setting bit 0 as 1 indicating the page is in memory
  279		 */
  280		for (int k = 0; k < PagesForProgram.length; k++) {







2016-04-29 00:36                  Scheduler.java                  Page 6


  281		processQueue.get(i).pageFaultBits.set(k,
  282				"1" + processQueue.get(i).pageFaultBits.get(k).substring(1, 3));
  283		}
  284		processQueue.get(i).currentSubqueueLevel = 1;
  285		subQueue1.add(processQueue.get(i));
  286		}
  287		if (PagesForProgram.length > emptyPagesOnMem || i == processQueue.size() - 1
  288				|| lastFewProcess == true) {
  289		if (subQueue1.size() > 0) {
  290		processQueSize = subQueue1.size();
  291		}
  292		if (subQueue2.size() > 0) {
  293		processQueSize += subQueue2.size();
  294		}
  295		if (subQueue3.size() > 0) {
  296		processQueSize += subQueue3.size();
  297		}
  298		if (subQueue4.size() > 0) {
  299		processQueSize += subQueue4.size();
  300		}
  301	
  302		cpu.setMemoryObject(memory);
  303		scheduleReadyProcesses();
  304		/*
  305		 * remove the disk and memory spaces allocated for terminated process and
  306		 * delete the terminated process from the process queue and branch back to
  307		 * loader.
  308		 */
  309		/* For Programs on disk */
  310		for (int j = 0; j < TerminatedQueue
  311				.getLast().ProgramPagesOnDisk.length; j++) {
  312		diskIndexToDeleteFrom = Integer
  313				.parseInt(TerminatedQueue.getLast().ProgramPagesOnDisk[j]);
  314		Loader.diskAvailability[diskIndexToDeleteFrom] = "true";
  315		Loader.emptyPagesOnDisk++;
  316		for (int k = diskIndexToDeleteFrom * 16; k < (diskIndexToDeleteFrom * 16)
  317				+ 16; k++) {
  318		diskReference.disk[k] = null;
  319		}
  320		}
  321		/* For data on disk */
  322		if (!(TerminatedQueue.getLast().currentOperation.equals("error")
  323				|| TerminatedQueue.getLast().errorDescription
  324						.equals("Missing Data"))) {
  325		for (int j = 0; j < TerminatedQueue.getLast().DataPagesOnDisk.length; j++) {
  326		diskIndexToDeleteFrom = Integer
  327				.parseInt(TerminatedQueue.getLast().DataPagesOnDisk[j]);
  328		Loader.diskAvailability[diskIndexToDeleteFrom] = "true";
  329		Loader.emptyPagesOnDisk++;
  330		for (int k = 16 * diskIndexToDeleteFrom; k < (diskIndexToDeleteFrom * 16)
  331				+ 16; k++) {
  332		diskReference.disk[k] = null;
  333		}
  334		}
  335		}
  336		/* output space on disk */







2016-04-29 00:36                  Scheduler.java                  Page 7


  337		for (int j = 0; j < TerminatedQueue
  338				.getLast().OutputPagesOnDisk.length; j++) {
  339		diskIndexToDeleteFrom = Integer
  340				.parseInt(TerminatedQueue.getLast().OutputPagesOnDisk[j]);
  341		Loader.diskAvailability[diskIndexToDeleteFrom] = "true";
  342		Loader.emptyPagesOnDisk++;
  343		for (int k = 16 * diskIndexToDeleteFrom; k < (diskIndexToDeleteFrom * 16)
  344				+ 16; k++) {
  345		diskReference.disk[k] = null;
  346		}
  347		}
  348		/* program on memory */
  349		for (int j = 0; j < TerminatedQueue
  350				.getLast().ProgramPagesOnMem.length; j++) {
  351		if (!TerminatedQueue.getLast().pageFaultBits.get(j).substring(0, 1)
  352				.equals("0")) {
  353		memIndexToDeleteFrom = Integer
  354				.parseInt(TerminatedQueue.getLast().ProgramPagesOnMem[j]);
  355		MemAvailability[memIndexToDeleteFrom] = "true";
  356		emptyPagesOnMem++;
  357		for (int k = 16 * memIndexToDeleteFrom; k < (memIndexToDeleteFrom * 16)
  358				+ 16; k++) {
  359		Memory.Mem[k] = null;
  360		}
  361		}
  362		}
  363		/* from process queue */
  364		terminatedJobID = TerminatedQueue.getLast().jobID;
  365		for (int j = 0; j < processQueue.size(); j++) {
  366		if (processQueue.get(j).jobID == terminatedJobID) {
  367		processIndexToDeleteFrom = j;
  368		break;
  369		}
  370		}
  371		processQueue.remove(processIndexToDeleteFrom);
  372		if (processQueue.isEmpty()) {
  373		}
  374		processQueSize--;
  375		break;
  376		}
  377		}
  378		if (processQueSize == processQueue.size() && processQueue.size() > 0) {
  379		lastFewProcess = true;
  380		processQueSize = 0;
  381		if (processQueue.size() == 1) {
  382		CPU.lastJob = true;
  383		}
  384		}
  385		} catch (Exception e) {
  386		break;
  387		}
  388		}
  389		}
  390		}
  391	
  392		private boolean scheduleReadyProcesses() {







2016-04-29 00:36                  Scheduler.java                  Page 8


  393		while (hasMore == true) {
  394		if (subQueue1.size() > 0) {
  395		runningQueue.add(subQueue1.getFirst());
  396		} else if (subQueue2.size() > 0) {
  397		runningQueue.add(subQueue2.getFirst());
  398		} else if (subQueue3.size() > 0) {
  399		runningQueue.add(subQueue3.getFirst());
  400		} else if (subQueue4.size() > 0) {
  401		runningQueue.add(subQueue4.getFirst());
  402		}
  403		// TODO:Need to uncomment and change this
  404		snapshotCPU();
  405		if (runningQueue.size() == 0) {
  406		System.out.print("");
  407		}
  408		subqueue1Size = subQueue1.size();
  409		subqueue2Size = subQueue2.size();
  410		subqueue3Size = subQueue3.size();
  411		subqueue4Size = subQueue4.size();
  412		if (subQueue1.size() > 0) {
  413		for (int j = 0; j < subQueue1.size(); j++) {
  414		contentOfSubqueue1.add(subQueue1.get(j).jobID);
  415		}
  416		}
  417		if (subQueue2.size() > 0) {
  418		for (int j = 0; j < subQueue2.size(); j++) {
  419		contentOfSubqueue2.add(subQueue2.get(j).jobID);
  420		}
  421		}
  422		if (subQueue3.size() > 0) {
  423		for (int j = 0; j < subQueue3.size(); j++) {
  424		contentOfSubqueue3.add(subQueue3.get(j).jobID);
  425		}
  426		}
  427		if (subQueue4.size() > 0) {
  428		for (int j = 0; j < subQueue4.size(); j++) {
  429		contentOfSubqueue4.add(subQueue4.get(j).jobID);
  430		}
  431		}
  432		hasMore = cpu.cpu(runningQueue.getFirst().PC,
  433				runningQueue.getFirst().traceFlag, runningQueue, diskReference);
  434		contentOfSubqueue1.clear();
  435		contentOfSubqueue2.clear();
  436		contentOfSubqueue3.clear();
  437		contentOfSubqueue4.clear();
  438		if (runningQueue.getFirst().currentOperation.equals("Read")) {
  439		/*
  440		 * The below method is called when nothing is terminated we just shift the
  441		 * states of process
  442		 */
  443		scheduleNextProcess();
  444		} else if (runningQueue.getFirst().currentOperation.equals("Write")) {
  445		scheduleNextProcess();
  446		} else if (runningQueue.getFirst().currentOperation.equals("TimeOut")) {
  447		scheduleNextProcessT();
  448		}







2016-04-29 00:36                  Scheduler.java                  Page 9


  449		}
  450		/*
  451		 * current process done executing or encountered some error while executing
  452		 */
  453		if (runningQueue.size() == 0) {
  454		System.out.print("");
  455		}
  456		terminateRunningProcess();
  457		hasMore = true;
  458		return false;
  459		}
  460	
  461		private void snapshotCPU() {
  462		runningQueue.getFirst().SystemStatus.clear();
  463		runningQueue.getFirst().SystemStatus.add("Status of the the system:");
  464		// runningQueue.getFirst().SystemStatus.add("Content of ready queue:");
  465		String temporary = "";
  466		for (int i = 0; i < subQueue1.size(); i++) {
  467		temporary += subQueue1.get(i).jobID + " ";
  468		}
  469		runningQueue.getFirst().SystemStatus.add(
  470				String.format("%-40s %-15s", "Content of subQueue1:", temporary));
  471		temporary = "";
  472		for (int i = 0; i < subQueue2.size(); i++) {
  473		temporary += subQueue2.get(i).jobID + " ";
  474		}
  475		runningQueue.getFirst().SystemStatus.add(
  476				String.format("%-40s %-15s", "Content of subQueue2:", temporary));
  477		temporary = "";
  478		for (int i = 0; i < subQueue3.size(); i++) {
  479		temporary += subQueue3.get(i).jobID + " ";
  480		}
  481		runningQueue.getFirst().SystemStatus.add(
  482				String.format("%-40s %-15s", "Content of subQueue3:", temporary));
  483		temporary = "";
  484		for (int i = 0; i < subQueue4.size(); i++) {
  485		temporary += subQueue4.get(i).jobID + " ";
  486		}
  487		runningQueue.getFirst().SystemStatus.add(
  488				String.format("%-40s %-15s", "Content of subQueue4:", temporary));
  489		String blockedQueueContent = "";
  490		for (int i = 0; i < BlockedQueue.size(); i++) {
  491		blockedQueueContent += BlockedQueue.get(i).jobID;
  492		}
  493		runningQueue.getFirst().SystemStatus.add(String.format("%-40s %-15s",
  494				"Content of Blocked Queue:", blockedQueueContent));
  495		if (runningQueue.size() > 0) {
  496		runningQueue.getFirst().SystemStatus.add(String.format("%-40s %-15s",
  497				"ID of current executing Job:", runningQueue.getFirst().jobID));
  498		} else {
  499		runningQueue.getFirst().SystemStatus.add(String.format("%-40s %-15s",
  500				"ID of current executing Job:", BlockedQueue.getFirst().jobID));
  501		}
  502		runningQueue.getFirst().SystemStatus.add(
  503				String.format("%-40s %-15s", "Memory Free:", emptyPagesOnMem * 16));
  504		runningQueue.getFirst().SystemStatus.add(String.format("%-40s %-15s",







2016-04-29 00:36                 Scheduler.java                  Page 10


  505				"Memory Used:", (256 - (emptyPagesOnMem * 16))));
  506		runningQueue.getFirst().SystemStatus.add(
  507				String.format("%-40s %-15s", "Current Degree of Multiprogramming:",
  508						(BlockedQueue.size() + subQueue1.size() + subQueue2.size()
  509								+ subQueue3.size() + subQueue4.size())));
  510		runningQueue.getFirst().SystemStatus
  511				.add("------------------------------------------------------");
  512		}
  513	
  514		private void scheduleNextProcessT() {
  515		/* adding the first process of ready list to the end of the list */
  516		if (BlockedQueue.size() > 0) {
  517		if (BlockedQueue.getFirst().currentSubqueueLevel == 1) {
  518		subQueue1.add(BlockedQueue.getFirst());
  519		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 2) {
  520		subQueue2.add(BlockedQueue.getFirst());
  521		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 3) {
  522		subQueue3.add(BlockedQueue.getFirst());
  523		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 4) {
  524		subQueue1.add(BlockedQueue.getFirst());
  525		subQueue1.getLast().currentSubqueueLevel = 1;
  526		}
  527		BlockedQueue.removeFirst();
  528		}
  529		if (runningQueue.getFirst().currentSubqueueLevel == 1) {
  530		if ((runningQueue.getFirst().TimeQuantum
  531				* runningQueue.getFirst().numberOfTurns) > (allowedNumberOfTurns
  532						* allowedQuantum)
  533				|| runningQueue.getFirst().numberOfTurns > allowedNumberOfTurns) {
  534		runningQueue.getFirst().currentSubqueueLevel = 2;
  535		runningQueue.getFirst().TimeQuantum = 0;
  536		subQueue2.add(runningQueue.getFirst());
  537		subQueue1.removeFirst();
  538		matrixMetric++;
  539		} else {
  540		subQueue1.add(subQueue1.getFirst());
  541		subQueue1.removeFirst();
  542		}
  543		} else if (runningQueue.getFirst().currentSubqueueLevel == 2) {
  544		if ((runningQueue.getFirst().TimeQuantum * runningQueue
  545				.getFirst().numberOfTurns) > ((allowedNumberOfTurns + 2)
  546						* allowedQuantum)
  547				|| runningQueue.getFirst().numberOfTurns > allowedNumberOfTurns
  548						+ 2) {
  549		runningQueue.getFirst().currentSubqueueLevel = 3;
  550		runningQueue.getFirst().TimeQuantum = 0;
  551		subQueue3.add(runningQueue.getFirst());
  552		subQueue2.removeFirst();
  553		matrixMetric++;
  554		} else {
  555		subQueue2.add(subQueue2.getFirst());
  556		subQueue2.removeFirst();
  557		}
  558		} else if (runningQueue.getFirst().currentSubqueueLevel == 3) {
  559		if ((runningQueue.getFirst().TimeQuantum * runningQueue
  560				.getFirst().numberOfTurns) > ((allowedNumberOfTurns + 4)







2016-04-29 00:36                 Scheduler.java                  Page 11


  561						* allowedQuantum)
  562				|| runningQueue.getFirst().numberOfTurns > allowedNumberOfTurns
  563						+ 4) {
  564		runningQueue.getFirst().currentSubqueueLevel = 4;
  565		runningQueue.getFirst().TimeQuantum = 0;
  566		subQueue4.add(runningQueue.getFirst());
  567		subQueue3.removeFirst();
  568		matrixMetric++;
  569		} else {
  570		subQueue3.add(subQueue3.getFirst());
  571		subQueue3.removeFirst();
  572		}
  573		} else if (runningQueue.getFirst().currentSubqueueLevel == 4) {
  574		if ((runningQueue.getFirst().TimeQuantum * runningQueue
  575				.getFirst().numberOfTurns) > ((allowedNumberOfTurns + 6)
  576						* allowedQuantum)
  577				|| (runningQueue.getFirst().TimeQuantum
  578						* runningQueue.getFirst().numberOfTurns) > (9
  579								* allowedQuantum * allowedNumberOfTurns)) {
  580		runningQueue.getFirst().currentSubqueueLevel = 1;
  581		runningQueue.getFirst().TimeQuantum = 0;
  582		subQueue1.add(runningQueue.getFirst());
  583		subQueue4.removeFirst();
  584		matrixMetric++;
  585		} else {
  586		subQueue4.add(subQueue4.getFirst());
  587		subQueue4.removeFirst();
  588		}
  589		}
  590		runningQueue.removeFirst();
  591		}
  592	
  593		private void terminateRunningProcess() {
  594		if (runningQueue.getFirst().currentSubqueueLevel == 1) {
  595		TerminatedQueue.add(subQueue1.getFirst());
  596		subQueue1.removeFirst();
  597		} else if (runningQueue.getFirst().currentSubqueueLevel == 2) {
  598		TerminatedQueue.add(subQueue2.getFirst());
  599		subQueue2.removeFirst();
  600		} else if (runningQueue.getFirst().currentSubqueueLevel == 3) {
  601		TerminatedQueue.add(subQueue3.getFirst());
  602		subQueue3.removeFirst();
  603		} else if (runningQueue.getFirst().currentSubqueueLevel == 4) {
  604		TerminatedQueue.add(subQueue4.getFirst());
  605		subQueue4.removeFirst();
  606		}
  607		runningQueue.removeFirst();
  608		if (BlockedQueue.size() > 0) {
  609		if (BlockedQueue.getFirst().currentSubqueueLevel == 1) {
  610		subQueue1.add(BlockedQueue.getFirst());
  611		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 2) {
  612		subQueue2.add(BlockedQueue.getFirst());
  613		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 3) {
  614		subQueue3.add(BlockedQueue.getFirst());
  615		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 4) {
  616		subQueue1.add(BlockedQueue.getFirst());







2016-04-29 00:36                 Scheduler.java                  Page 12


  617		subQueue1.getLast().currentSubqueueLevel = 1;
  618		}
  619		BlockedQueue.removeFirst();
  620		}
  621		}
  622	
  623		private void scheduleNextProcess() {
  624		if (Loader.fileEndedExecuteAnyways == true && processQueue.size() == 1) {
  625		/*
  626		 * do nothing we have only one process let it have the CPU even if IO is
  627		 * being performed
  628		 */
  629		runningQueue.removeFirst();
  630	
  631		} else {
  632		/* unblock the process and put them into appropriate sub queues */
  633		if (BlockedQueue.size() > 0) {
  634		if (BlockedQueue.getFirst().currentSubqueueLevel == 1) {
  635		subQueue1.add(BlockedQueue.getFirst());
  636		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 2) {
  637		subQueue2.add(BlockedQueue.getFirst());
  638		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 3) {
  639		subQueue3.add(BlockedQueue.getFirst());
  640		} else if (BlockedQueue.getFirst().currentSubqueueLevel == 4) {
  641		subQueue1.add(BlockedQueue.getFirst());
  642		subQueue1.getLast().currentSubqueueLevel = 1;
  643		}
  644		BlockedQueue.removeFirst();
  645		}
  646		/*
  647		 * put the running process into blocked queue because it asked for I/O
  648		 */
  649		if (runningQueue.getFirst().currentSubqueueLevel == 1) {
  650		BlockedQueue.add(subQueue1.getFirst());
  651		subQueue1.removeFirst();
  652		} else if (runningQueue.getFirst().currentSubqueueLevel == 2) {
  653		BlockedQueue.add(subQueue2.getFirst());
  654		subQueue2.removeFirst();
  655		} else if (runningQueue.getFirst().currentSubqueueLevel == 3) {
  656		BlockedQueue.add(subQueue3.getFirst());
  657		subQueue3.removeFirst();
  658		} else if (runningQueue.getFirst().currentSubqueueLevel == 4) {
  659		BlockedQueue.add(subQueue4.getFirst());
  660		subQueue4.removeFirst();
  661		}
  662		runningQueue.removeFirst();
  663		}
  664		}
  665	
  666		private void writeDiskContentToMem(String[] pagesForProgram2, int lenth,
  667				int jobid) {
  668		int programIndex = 0;
  669		PageIndex = 0;
  670		try {
  671		while (PageIndex < 16 && programIndex < pagesForProgram2.length) {
  672		if (MemAvailability[PageIndex].equals("true")) {







2016-04-29 00:36                 Scheduler.java                  Page 13


  673		MemAvailability[PageIndex] = "false";
  674		int thisPageIndexInDisk = Integer.parseInt(pagesForProgram2[programIndex]);
  675		for (int i = thisPageIndexInDisk * 16, j = 0; i < (thisPageIndexInDisk * 16)
  676				+ 16; i++, j++) {
  677		blockForMem[j] = diskReference.disk[i];
  678		}
  679		memory.writeToMemory("WRIT", PageIndex, blockForMem);
  680		_ProgramPagesOnMem.add(Integer.toString(PageIndex));
  681		emptyPagesOnMem--;
  682		programIndex++;
  683		}
  684		PageIndex++;
  685		}
  686		int temp = _ProgramPagesOnMem.size();
  687		for (int i = temp; i < lenth; i++) {
  688		_ProgramPagesOnMem.add(null);
  689		}
  690		} catch (Exception e) {
  691		ErrorHandler.setJobID(jobid);
  692		err.HandleError(ErrorHandler.OUT_OF_BOUNDS);
  693	
  694		}
  695	
  696		}
  697	}






































2016-04-29 02:24                   system.java                    Page 1


    1	
    2	/*Name: Gautham Brahma Ponnaganti.
    3	 *Course No.: CS5323
    4	 *Assignment title:OS Project PHASE II
    5	 *Date:4-28-2016
    6	 *Global Variables:
    7	 *-ErrorHandler:instance of error handler to trap errors if any that occurs.
    8	 *
    9	 *Brief description: This is where the execution of the system starts with. It will call loader sub-system and 
   10	 *the execution will branch back to here if there is any error occurs. 
   11	 *
   12	 *Changes in PhaseIII:Made changes for multilevel feedback queues
   13	 */
   14	
   15	import java.io.*;
   16	import java.util.ArrayList;
   17	
   18	public class system {
   19		public static String fileNameToAppend;
   20	
   21		public void begin(String fileName) {
   22		try {
   23		String filename = "MLFBQ.txt";
   24		FileWriter fw = new FileWriter(filename);
   25		fw.close();
   26		} catch (IOException e) {
   27		e.printStackTrace();
   28		}
   29		ArrayList<Integer> matrix = new ArrayList<Integer>();
   30		if (fileName.contains(".txt"))
   31			fileNameToAppend = fileName.substring(0, fileName.indexOf(".txt"));
   32		else
   33			fileNameToAppend = fileName;
   34		File file = new File(fileName);
   35		File output = new File("output");
   36		if (output.delete()) {
   37		File outputFile = new File("output");
   38		}
   39		if (!file.exists()) {
   40		errorHandler.HandleError(ErrorHandler.FILE_NOT_FOUND);
   41		HandleError(ErrorHandler.FILE_NOT_FOUND);
   42		}
   43		for (int i = 3; i <= 5; i++) {
   44		for (int j = 35; j <= 50; j = j + 5) {
   45		Scheduler.allowedNumberOfTurns = i;
   46		Scheduler.allowedQuantum = j;
   47		Loader loader = new Loader();
   48		loader.loader(file);
   49		matrix.add(Scheduler.matrixMetric);
   50		clearStaticVariables();
   51		}
   52		}
   53		try {
   54		String filename = "3x4Matrix.txt";
   55		FileWriter fw = new FileWriter(filename);
   56		fw.write(String.format("%-5s %-5s %-5s %-5s %-5s", "", "35", "40", "45",







2016-04-29 02:24                   system.java                    Page 2


   57				"50"));
   58		fw.write("\n");
   59		fw.write(String.format("%-5s %-5s %-5s %-5s %-5s", "3", matrix.get(0),
   60				matrix.get(1), matrix.get(2), matrix.get(3)));
   61		fw.write("\n");
   62		fw.write(String.format("%-5s %-5s %-5s %-5s %-5s", "4", matrix.get(4),
   63				matrix.get(5), matrix.get(6), matrix.get(7)));
   64		fw.write("\n");
   65		fw.write(String.format("%-5s %-5s %-5s %-5s %-5s", "5", matrix.get(8),
   66				matrix.get(9), matrix.get(10), matrix.get(11)));
   67		fw.write("\n");
   68		fw.close();
   69		} catch (IOException e) {
   70		e.printStackTrace();
   71		}
   72		}
   73	
   74		private void clearStaticVariables() {
   75		for (int i = 0; i < Loader.diskAvailability.length; i++) {
   76		Loader.diskAvailability[i] = null;
   77		}
   78		Loader.emptyPagesOnDisk = 255;
   79		Loader.fileEndedExecuteAnyways = false;
   80		Loader.NOJITB = 0;
   81		Loader.executionEnded = false;
   82		CPU.lastJob = false;
   83		Scheduler.matrixMetric = 0;
   84		}
   85	
   86		private void HandleError(int warningCode) {
   87		if (warningCode == ErrorHandler.FILE_NOT_FOUND) {
   88		System.out.println("File not found");
   89		}
   90		if (warningCode == ErrorHandler.SYSTEM_ERROR) {
   91		System.out.println("System Internal Error.");
   92		}
   93		}
   94	
   95		static ErrorHandler errorHandler = new ErrorHandler();
   96	
   97		/* Execution starting point */
   98		public static void main(String[] args) {
   99		/* check for number of arguments passed as a file name */
  100		String FileName = null;
  101	
  102		system systemObject = new system();
  103		if (args.length > 0) {
  104		FileName = args[0];
  105		}
  106		/* Begin the system by passing the File Name */
  107		try {
  108		systemObject.begin(FileName);
  109		} catch (Exception e) {
  110		errorHandler.HandleError(ErrorHandler.SYSTEM_ERROR);
  111		}
  112		}







2016-04-29 02:24                   system.java                    Page 3


  113	}





























































java system /home/opsys/SPR16/tb


cat -n progressFile.txt|head -40

     1	
     2	JobID loaded(DEC):                       1              
     3	Clock value during load(Decimal):        9801056        
     4	------------------------------------------------------
     5	JobID loaded(DEC):                       2              
     6	Clock value during load(Decimal):        9801056        
     7	------------------------------------------------------
     8	JobID loaded(DEC):                       3              
     9	Clock value during load(Decimal):        9801056        
    10	------------------------------------------------------
    11	JobID loaded(DEC):                       4              
    12	Clock value during load(Decimal):        9801056        
    13	------------------------------------------------------
    14	JobID loaded(DEC):                       5              
    15	Clock value during load(Decimal):        9801056        
    16	------------------------------------------------------
    17	JobID loaded(DEC):                       6              
    18	Clock value during load(Decimal):        9801056        
    19	------------------------------------------------------
    20	JobID loaded(DEC):                       7              
    21	Clock value during load(Decimal):        9801056        
    22	------------------------------------------------------
    23	JobID loaded(DEC):                       8              
    24	Clock value during load(Decimal):        9801056        
    25	------------------------------------------------------
    26	JobID loaded(DEC):                       9              
    27	Clock value during load(Decimal):        9801056        
    28	------------------------------------------------------
    29	JobID loaded(DEC):                       10             
    30	Clock value during load(Decimal):        9801056        
    31	------------------------------------------------------
    32	JobID loaded(DEC):                       11             
    33	Clock value during load(Decimal):        9801056        
    34	------------------------------------------------------
    35	JobID loaded(DEC):                       12             
    36	Clock value during load(Decimal):        9801056        
    37	------------------------------------------------------
    38	JobID loaded(DEC):                       13             
    39	Clock value during load(Decimal):        9801056        
    40	------------------------------------------------------

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -3000| head -40

   577	  00000000   00000000   00000000   00000000
   578	  00000000   00000000   00000000   00000000
   579	  00000000   00000000   00000000   00000000
   580	  00000000   01300015   02300021   10000021
   581	  00000000   00000000   00000002   00000008
   582	  0000000a   00000004   00000000   00000000
   583	  00000000   00000005   00000000   00000000
   584	  00000000   01100015   0A100013   01100018
   585	  01000014   0210001D   04010021   0B00000F
   586	  0310001C   01300020   0430001D   0430001C
   587	  0A300004   10000018   0C100000   01210021
   588	  0220001F   1000001C   0C100000   00000000
   589	  00000500   00000000   00000000   00000000
   590	  00000000   00000000   00000000   00000000
   591	  00000001   00000003   00000000   00001d09
   592	  0F000014   01100015   0A100013   01100018
   593	  01000014   0210001D   04010021   0B00000F
   594	  0310001C   01300020   0430001D   0430001C
   595	  0A300004   10000018   0C100000   01210021
   596	  0220001F   1000001C   0C100000   00000000
   597	  00000500   00000000   00000000   00000000
   598	  00000000   00000000   00000000   00000000
   599	  00000001   00000003   00000000   00001d09
   600	  0F00001D   0110001D   0B100019   01100021
   601	  0210001E   0120001D   0130001E   05300023
   602	  0230001F   0720001F   01300024   05300023
   603	  02300020   08200020   0720001F   0220001A
   604	  0310001A   0130001E   03300022   0230001E
   605	  04300025   09300005   0210001A   1000001A
   606	  0C100000   00000000   00000000   00000000
   607	  00000000   98989898   00000003   0000000c
   608	  00000003   00000005   00000008   0000000d
   609	  00000015   00000022   00000037   00000059
   610	  00000090   00000000   00000000   00000000
   611	  00000000   00000000   00000000   00000000
   612	  04D00016   0AD0000A   90000018   90000019
   613	  9000001A   00000000   00000001   0000000A
   614	  0000001D   00000021   00000025   00000059
   615	  00000090   00000001   00000001   00000002
   616	  0F00000F   0120000D   0110000F   0B100009

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -1400|head -40

  2177	
  2178	Completed Execution for jobID(DEC):      101            
  2179	Current value of the clock(Decimal):     51340          
  2180	clock at load time(hex):                 c652           
  2181	Clock at termination time(hex):          c88c           
  2182	Number of chances at the CPU:            11             
  2183	job Output(Hex):
  2184	  00000037   00000000   00000000   00000000
  2185	Memory Dump:
  2186	  8F000020   01100023   0B10001E   01100020
  2187	  01200023   01300021   0C40000B   81100020
  2188	  0B10001C   09100016   0A100003   02400026
  2189	  02100027   02200028   02300029   81500027
  2190	  00000022   00000024   0006ca32   00000076
  2191	  00000076   00000000   00000006   00000022
  2192	  00000076   00000024   00000000   00000000
  2193	  00000000   00000000   00000000   00000000
  2194	  0F00000F   0120000D   0110000F   0B100009
  2195	  09100009   0F000013   03200013   0410000E
  2196	  0A100005   02200017   10000017   11000000
  2197	  00000000   00000000   00000001   0000000A
  2198	  00000000   00000000   00000000   0000000A
  2199	  00000000   00000000   00000000   00000037
  2200	  00000000   00000000   00000000   00000000
  2201	  00000000   00000000   00000000   00000000
  2202	  04500028   82500027   81600029   0360001F
  2203	  82600029   0C400007   03100023   0120001F
  2204	  02120024   01100024   0410001F   02100024
  2205	  10000022   0C100000   00000000   00000001
  2206	  00000022   00000024   0006ccf6   00000076
  2207	  00000070   00000000   00000006   00000022
  2208	  00000076   00000024   00000000   00000000
  2209	  00000000   00000000   00000000   00000000
  2210	  01310048   0435004C   0A300016   01310048
  2211	  0235004C   02210048   01100044   0A100007
  2212	  01500043   03500041   0A500001   01400040
  2213	  10040047   03400042   10040047   03400042
  2214	  00000000   00000001   00000004   00000002
  2215	  00000008   00000004   00000222   0000000A
  2216	  00000001   00000006   00000200   00000004

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -600|head -40

  2977	Memory Used:                             192            
  2978	Current Degree of Multiprogramming:      6              
  2979	------------------------------------------------------
  2980	
  2981	Status of the the system:
  2982	Content of subQueue1:                                   
  2983	Content of subQueue2:                                   
  2984	Content of subQueue3:                                   
  2985	Content of subQueue4:                    9 78 57 25 31 60 
  2986	Content of Blocked Queue:                               
  2987	ID of current executing Job:             9              
  2988	Memory Free:                             64             
  2989	Memory Used:                             192            
  2990	Current Degree of Multiprogramming:      6              
  2991	------------------------------------------------------
  2992	
  2993	Status of the the system:
  2994	Content of subQueue1:                    9              
  2995	Content of subQueue2:                                   
  2996	Content of subQueue3:                                   
  2997	Content of subQueue4:                    78 57 25 31 60 
  2998	Content of Blocked Queue:                               
  2999	ID of current executing Job:             9              
  3000	Memory Free:                             64             
  3001	Memory Used:                             192            
  3002	Current Degree of Multiprogramming:      6              
  3003	------------------------------------------------------
  3004	
  3005	Status of the the system:
  3006	Content of subQueue1:                                   
  3007	Content of subQueue2:                    9              
  3008	Content of subQueue3:                                   
  3009	Content of subQueue4:                    78 57 25 31 60 
  3010	Content of Blocked Queue:                               
  3011	ID of current executing Job:             9              
  3012	Memory Free:                             64             
  3013	Memory Used:                             192            
  3014	Current Degree of Multiprogramming:      6              
  3015	------------------------------------------------------
  3016	

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -200|head -40

  3377	Status of the the system:
  3378	Content of subQueue1:                                   
  3379	Content of subQueue2:                    57             
  3380	Content of subQueue3:                                   
  3381	Content of subQueue4:                    25 31 60 9 78  
  3382	Content of Blocked Queue:                               
  3383	ID of current executing Job:             57             
  3384	Memory Free:                             64             
  3385	Memory Used:                             192            
  3386	Current Degree of Multiprogramming:      6              
  3387	------------------------------------------------------
  3388	
  3389	Status of the the system:
  3390	Content of subQueue1:                                   
  3391	Content of subQueue2:                                   
  3392	Content of subQueue3:                    57             
  3393	Content of subQueue4:                    25 31 60 9 78  
  3394	Content of Blocked Queue:                               
  3395	ID of current executing Job:             57             
  3396	Memory Free:                             64             
  3397	Memory Used:                             192            
  3398	Current Degree of Multiprogramming:      6              
  3399	------------------------------------------------------
  3400	
  3401	Status of the the system:
  3402	Content of subQueue1:                                   
  3403	Content of subQueue2:                                   
  3404	Content of subQueue3:                    78             
  3405	Content of subQueue4:                    60 9 25 57 31  
  3406	Content of Blocked Queue:                               
  3407	ID of current executing Job:             78             
  3408	Memory Free:                             64             
  3409	Memory Used:                             192            
  3410	Current Degree of Multiprogramming:      6              
  3411	------------------------------------------------------
  3412	
  3413	Status of the the system:
  3414	Content of subQueue1:                    60             
  3415	Content of subQueue2:                                   
  3416	Content of subQueue3:                                   

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -40

  3537	Clock at termination time(hex):          f2e31          
  3538	Number of chances at the CPU:            5056           
  3539	job Output(Hex):
  3540	  00000000   0000000F   00000003   00000000
  3541	  00000000   00000076   00000f31   00000000
  3542	  800530ed   00054321   00000000   00001234
  3543	  00000000   00000017   00000093   00000000
  3544	Nature of termination:                   Normal         
  3545	Runtime(Decimal):                        282931         
  3546	TurnAroundTime(Decimal):                 965518         
  3547	Execution Time(Decimal):                 282931         
  3548	Page Fault Handling Time(Decimal):       124125         
  3549	------------------------------------------------------
  3550	
  3551	Report for Batch:
  3552	Current Clock Value:(HEX)                             f2e31          
  3553	Mean user job run time:(DEC)                          51.73          
  3554	Mean user job I/O time:(DEC)                          51.73          
  3555	Mean user job execution time:(DEC)                    5718.13        
  3556	Mean user job time in the System:(DEC)                9566.01        
  3557	Mean user job page fault handling time(DEC):          7167.69        
  3558	Total CPU idle time(HEX):                             48             
  3559	Time lost due to abnormally terminated jobs(HEX):     0              
  3560	Number of jobs that terminated normally(DEC):         104            
  3561	Number of jobs that terminated abnormally(DEC):       0              
  3562	Total Time lost due to Suspected Infinite jobs(HEX):  0              
  3563	ID's of jobs considered Infinite(DEC):                []             
  3564	Total Number of page faults(HEX):                     24660          
  3565	percentage of Disk Occupied(DEC):                     97             
  3566	Number of holes(DEC):                                 2              
  3567	average size of holes(DEC):                           1              
  3568	average size of holes(DEC):                           1              
  3569	Maximum size of subqueue 1(DEC):                      8              
  3570	Maximum size of subqueue 2:(DEC)                      7              
  3571	Maximum size of subqueue 3:(DEC)                      8              
  3572	Maximum size of subqueue 4:(DEC)                      8              
  3573	Average size of subqueue 1(DEC)                       0.21           
  3574	Average size of subqueue 2(DEC)                       0.37           
  3575	Average size of subqueue 3(DEC)                       0.20           
  3576	Average size of subqueue 4(DEC)                       5.31           

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n MLFBQ.txt|head -60

     1	Clock value(Hex):         1231      
     2	Contents of subqueue1(DEC): [11]      
     3	Contents of subqueue2(DEC): [2, 3]    
     4	Contents of subqueue3(DEC): [1, 7, 6, 9, 10]
     5	Contents of subqueue4(DEC): Empty     
     6	
     7	Clock value(Hex):         2466      
     8	Contents of subqueue1(DEC): [17]      
     9	Contents of subqueue2(DEC): Empty     
    10	Contents of subqueue3(DEC): [2, 13, 14]
    11	Contents of subqueue4(DEC): [1, 6, 9, 3]
    12	
    13	Clock value(Hex):         3697      
    14	Contents of subqueue1(DEC): Empty     
    15	Contents of subqueue2(DEC): Empty     
    16	Contents of subqueue3(DEC): Empty     
    17	Contents of subqueue4(DEC): [6, 9, 3, 13, 22, 24, 1, 25]
    18	
    19	Clock value(Hex):         4899      
    20	Contents of subqueue1(DEC): Empty     
    21	Contents of subqueue2(DEC): Empty     
    22	Contents of subqueue3(DEC): [32, 13]  
    23	Contents of subqueue4(DEC): [9, 22, 24, 25, 31, 3]
    24	
    25	Clock value(Hex):         6109      
    26	Contents of subqueue1(DEC): Empty     
    27	Contents of subqueue2(DEC): [41]      
    28	Contents of subqueue3(DEC): Empty     
    29	Contents of subqueue4(DEC): [25, 31, 3, 13, 9, 22]
    30	
    31	Clock value(Hex):         7319      
    32	Contents of subqueue1(DEC): [45]      
    33	Contents of subqueue2(DEC): Empty     
    34	Contents of subqueue3(DEC): Empty     
    35	Contents of subqueue4(DEC): [22, 41, 25, 31, 3, 13, 9]
    36	
    37	Clock value(Hex):         8547      
    38	Contents of subqueue1(DEC): [49, 25]  
    39	Contents of subqueue2(DEC): Empty     
    40	Contents of subqueue3(DEC): Empty     
    41	Contents of subqueue4(DEC): [46, 31, 13, 9, 48, 41]
    42	
    43	Clock value(Hex):         9765      
    44	Contents of subqueue1(DEC): Empty     
    45	Contents of subqueue2(DEC): [9]       
    46	Contents of subqueue3(DEC): Empty     
    47	Contents of subqueue4(DEC): [48, 25, 41, 31, 52, 51, 13]
    48	
    49	Clock value(Hex):         10974     
    50	Contents of subqueue1(DEC): [25]      
    51	Contents of subqueue2(DEC): Empty     
    52	Contents of subqueue3(DEC): Empty     
    53	Contents of subqueue4(DEC): [31, 52, 51, 13, 9, 48]
    54	
    55	Clock value(Hex):         12187     
    56	Contents of subqueue1(DEC): Empty     
    57	Contents of subqueue2(DEC): Empty     
    58	Contents of subqueue3(DEC): Empty     
    59	Contents of subqueue4(DEC): [51, 57, 13, 9, 48, 25, 31, 52]
    60	

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n MLFBQ.txt|tail -60

 55687	Clock value(Hex):         983586    
 55688	Contents of subqueue1(DEC): Empty     
 55689	Contents of subqueue2(DEC): Empty     
 55690	Contents of subqueue3(DEC): Empty     
 55691	Contents of subqueue4(DEC): [57, 31, 60, 78, 9, 25]
 55692	
 55693	Clock value(Hex):         984816    
 55694	Contents of subqueue1(DEC): Empty     
 55695	Contents of subqueue2(DEC): Empty     
 55696	Contents of subqueue3(DEC): [78]      
 55697	Contents of subqueue4(DEC): [9, 25, 57, 31, 60]
 55698	
 55699	Clock value(Hex):         986029    
 55700	Contents of subqueue1(DEC): [31]      
 55701	Contents of subqueue2(DEC): Empty     
 55702	Contents of subqueue3(DEC): Empty     
 55703	Contents of subqueue4(DEC): [60, 78, 9, 25, 57]
 55704	
 55705	Clock value(Hex):         987259    
 55706	Contents of subqueue1(DEC): Empty     
 55707	Contents of subqueue2(DEC): Empty     
 55708	Contents of subqueue3(DEC): [9]       
 55709	Contents of subqueue4(DEC): [25, 57, 31, 60, 78]
 55710	
 55711	Clock value(Hex):         988464    
 55712	Contents of subqueue1(DEC): [60]      
 55713	Contents of subqueue2(DEC): Empty     
 55714	Contents of subqueue3(DEC): Empty     
 55715	Contents of subqueue4(DEC): [78, 9, 25, 57, 31]
 55716	
 55717	Clock value(Hex):         989668    
 55718	Contents of subqueue1(DEC): Empty     
 55719	Contents of subqueue2(DEC): Empty     
 55720	Contents of subqueue3(DEC): [25]      
 55721	Contents of subqueue4(DEC): [57, 31, 60, 78, 9]
 55722	
 55723	Clock value(Hex):         990885    
 55724	Contents of subqueue1(DEC): Empty     
 55725	Contents of subqueue2(DEC): Empty     
 55726	Contents of subqueue3(DEC): Empty     
 55727	Contents of subqueue4(DEC): [57, 60, 78]
 55728	
 55729	Clock value(Hex):         992100    
 55730	Contents of subqueue1(DEC): Empty     
 55731	Contents of subqueue2(DEC): [57]      
 55732	Contents of subqueue3(DEC): Empty     
 55733	Contents of subqueue4(DEC): [60, 78]  
 55734	
 55735	Clock value(Hex):         993307    
 55736	Contents of subqueue1(DEC): Empty     
 55737	Contents of subqueue2(DEC): [78]      
 55738	Contents of subqueue3(DEC): Empty     
 55739	Contents of subqueue4(DEC): Empty     
 55740	
 55741	Clock value(Hex):         994518    
 55742	Contents of subqueue1(DEC): Empty     
 55743	Contents of subqueue2(DEC): Empty     
 55744	Contents of subqueue3(DEC): Empty     
 55745	Contents of subqueue4(DEC): [78]      
 55746	

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n MLFBQ.txt|tail -1400|head -60

 54347	Contents of subqueue4(DEC): [78, 57, 25, 31, 60]
 54348	
 54349	Clock value(Hex):         712093    
 54350	Contents of subqueue1(DEC): Empty     
 54351	Contents of subqueue2(DEC): Empty     
 54352	Contents of subqueue3(DEC): [25]      
 54353	Contents of subqueue4(DEC): [31, 60, 9, 78, 57]
 54354	
 54355	Clock value(Hex):         713316    
 54356	Contents of subqueue1(DEC): Empty     
 54357	Contents of subqueue2(DEC): [78]      
 54358	Contents of subqueue3(DEC): Empty     
 54359	Contents of subqueue4(DEC): [57, 25, 31, 60, 9]
 54360	
 54361	Clock value(Hex):         714542    
 54362	Contents of subqueue1(DEC): Empty     
 54363	Contents of subqueue2(DEC): Empty     
 54364	Contents of subqueue3(DEC): Empty     
 54365	Contents of subqueue4(DEC): [60, 9, 78, 57, 25, 31]
 54366	
 54367	Clock value(Hex):         715766    
 54368	Contents of subqueue1(DEC): Empty     
 54369	Contents of subqueue2(DEC): [57]      
 54370	Contents of subqueue3(DEC): Empty     
 54371	Contents of subqueue4(DEC): [25, 31, 60, 9, 78]
 54372	
 54373	Clock value(Hex):         716981    
 54374	Contents of subqueue1(DEC): Empty     
 54375	Contents of subqueue2(DEC): Empty     
 54376	Contents of subqueue3(DEC): Empty     
 54377	Contents of subqueue4(DEC): [9, 78, 57, 25, 31, 60]
 54378	
 54379	Clock value(Hex):         718188    
 54380	Contents of subqueue1(DEC): Empty     
 54381	Contents of subqueue2(DEC): [25]      
 54382	Contents of subqueue3(DEC): Empty     
 54383	Contents of subqueue4(DEC): [31, 60, 9, 78, 57]
 54384	
 54385	Clock value(Hex):         719418    
 54386	Contents of subqueue1(DEC): Empty     
 54387	Contents of subqueue2(DEC): Empty     
 54388	Contents of subqueue3(DEC): Empty     
 54389	Contents of subqueue4(DEC): [78, 57, 25, 31, 60, 9]
 54390	
 54391	Clock value(Hex):         720629    
 54392	Contents of subqueue1(DEC): Empty     
 54393	Contents of subqueue2(DEC): [31]      
 54394	Contents of subqueue3(DEC): Empty     
 54395	Contents of subqueue4(DEC): [60, 9, 78, 57, 25]
 54396	
 54397	Clock value(Hex):         721855    
 54398	Contents of subqueue1(DEC): [57]      
 54399	Contents of subqueue2(DEC): Empty     
 54400	Contents of subqueue3(DEC): Empty     
 54401	Contents of subqueue4(DEC): [25, 31, 60, 9, 78]
 54402	
 54403	Clock value(Hex):         723070    
 54404	Contents of subqueue1(DEC): Empty     
 54405	Contents of subqueue2(DEC): [60]      
 54406	Contents of subqueue3(DEC): Empty     

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n 3x4Matrix.txt

     1	      35    40    45    50   
     2	3     36110 39390 36902 30771
     3	4     36209 32927 36895 30741
     4	5     43122 32927 36895 30741

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n trace-JobID-100.txt|head -20

     1	PC(DEC) Instruction(HEX)   A Before(HEX)    A After(HEX)         EA(HEX) 
     2	   0         f00000a              00              00              2a 
     3	  33         120000e              00              02              2e 
     4	  34         110000a              00              06              2a 
     5	  35         710000e              06              00              2e 
     6	  36         210000a              00              00              2a 
     7	   0        1000000a              00              00              2a 
     8	  38         810000e              00              00              2e 
     9	  39         210000a              00              00              2a 
    10	   0        1000000a              00              00              2a 
    11	   0              00              00              00              20 

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n trace-JobID-100.txt|tail -20

     1	PC(DEC) Instruction(HEX)   A Before(HEX)    A After(HEX)         EA(HEX) 
     2	   0         f00000a              00              00              2a 
     3	  33         120000e              00              02              2e 
     4	  34         110000a              00              06              2a 
     5	  35         710000e              06              00              2e 
     6	  36         210000a              00              00              2a 
     7	   0        1000000a              00              00              2a 
     8	  38         810000e              00              00              2e 
     9	  39         210000a              00              00              2a 
    10	   0        1000000a              00              00              2a 
    11	   0              00              00              00              20 

cat -n trace-JobID-10.txt|head -20

     1	PC(DEC) Instruction(HEX)   A Before(HEX)    A After(HEX)         EA(HEX) 
     2	   0         f000018              00              00              38 
     3	  33         1100018              00              05              38 
     4	  34         b100017              05              05              37 
     5	  35         9100017              05              05              37 
     6	  36         410001c              05              04              3c 
     7	  37         b100017              04              04              37 
     8	  38         1100018              04              05              38 
     9	  39         120001d              00              01              3d 
    10	  40         320001c              01              02              3c 
    11	  41         220001d              02              02              3d 
    12	  42         610001d              05              02              3d 
    13	  43         510001d              02              04              3d 
    14	  44         210001e              04              04              3e 
    15	  45         1100018              04              05              38 
    16	  46         410001e              05              01              3e 
    17	  47         b100016              01              01              36 
    18	  48         1100018              01              05              38 
    19	  49         410001d              05              03              3d 
    20	  50         410001c              03              02              3c 

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n trace-JobID-10.txt|tail -20

    34	  50         410001c              02              01              3c 
    35	  51         a100006              01              01              26 
    36	  38         1100018              01              05              38 
    37	  39         120001d              03              03              3d 
    38	  40         320001c              03              04              3c 
    39	  41         220001d              04              04              3d 
    40	  42         610001d              05              01              3d 
    41	  43         510001d              01              04              3d 
    42	  44         210001e              04              04              3e 
    43	  45         1100018              04              05              38 
    44	  46         410001e              05              01              3e 
    45	  47         b100016              01              01              36 
    46	  48         1100018              01              05              38 
    47	  49         410001d              05              01              3d 
    48	  50         410001c              01              00              3c 
    49	  51         a100006              00              00              26 
    50	  52         110001f              00              00              3f 
    51	  53         2100020              00              00              20 
    52	   0        10000020              00              00              20 
    53	   0              00              00              00              30 

cat -n trace-JobID-65.txt|head -20

     1	PC(DEC) Instruction(HEX)   A Before(HEX)    A After(HEX)         EA(HEX) 
     2	   0         f000014              00              00              74 
     3	  97         1100015              00              00              75 
     4	  98         a100013              00              00              73 
     5	  99         1100018              00              00              78 
     6	 100         1000014              00            1d09              74 
     7	 101         210001d              00              00              7d 
     8	 102         4010021            1d09            1d05              61 
     9	 103         b00000f            1d05            1d05              6f 
    10	 104         310001c              00              01              7c 
    11	 105         1300020              00              08              60 
    12	 106         430001d              08              08              7d 
    13	 107         430001c              08              07              7c 
    14	 108         a300004              07              07              64 
    15	 100         1000014            1d05            1d09              74 
    16	 101         210001d              01              01              7d 
    17	 102         4010021            1d09            1d02              62 
    18	 103         b00000f            1d02            1d02              6f 
    19	 104         310001c              01              02              7c 
    20	 105         1300020              07              08              60 

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n trace-JobID-65.txt|tail -20

   142	 101         210001d              03              03              7d 
   143	 102         4010021            2ee1            2bae              64 
   144	 103         b00000f            2bae            2bae              6f 
   145	 104         310001c              03              04              7c 
   146	 105         1300020              05              08              60 
   147	 106         430001d              08              05              7d 
   148	 107         430001c              05              04              7c 
   149	 108         a300004              04              04              64 
   150	 100         1000014            2bae            2ee1              74 
   151	 101         210001d              04              04              7d 
   152	 102         4010021            2ee1              00              65 
   153	 103         b00000f              00              00              6f 
   154	 111         1210021            1d09            2ee1              65 
   155	 112         220001f            2ee1            2ee1              7f 
   156	   0        1000001c              00              00              7c 
   157	 114         c100000              04              12              60 
   158	   0         f000014              00              00              74 
   159	  97         1100015              12              01              75 
   160	  98         a100013              01              01              73 
   161	   0              00              00              00              60 

cat -n trace-JobID-75.txt|head -20

     1	PC(DEC) Instruction(HEX)   A Before(HEX)    A After(HEX)         EA(HEX) 
     2	   0         f00000f              00              00              8f 
     3	 129         120000d              00              00              8d 
     4	 130         110000f              00              0a              8f 
     5	 131         b100009              0a              0a              89 
     6	 132         9100009              0a              0a              89 
     7	   0         f000013              00              00              93 
     8	 134         3200013              00              01              93 
     9	 135         410000e              0a              09              8e 
    10	 136         a100005              09              09              85 
    11	   0         f000013              00              00              93 
    12	 134         3200013              01              03              93 
    13	 135         410000e              09              08              8e 
    14	 136         a100005              08              08              85 
    15	   0         f000013              00              00              93 
    16	 134         3200013              03              06              93 
    17	 135         410000e              08              07              8e 
    18	 136         a100005              07              07              85 
    19	   0         f000013              00              00              93 
    20	 134         3200013              06              0a              93 

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n trace-JobID-75.txt|tail -20

    31	   0         f000013              00              00              93 
    32	 134         3200013              15              1c              93 
    33	 135         410000e              04              03              8e 
    34	 136         a100005              03              03              85 
    35	   0         f000013              00              00              93 
    36	 134         3200013              1c              24              93 
    37	 135         410000e              03              02              8e 
    38	 136         a100005              02              02              85 
    39	   0         f000013              00              00              93 
    40	 134         3200013              24              2d              93 
    41	 135         410000e              02              01              8e 
    42	 136         a100005              01              01              85 
    43	   0         f000013              00              00              93 
    44	 134         3200013              2d              37              93 
    45	 135         410000e              01              00              8e 
    46	 136         a100005              00              00              85 
    47	 137         2200017              37              37              97 
    48	   0        10000017              00              00              97 
    49	 139        11000000              00              00              80 
    50	   0              00              00              00              80 

java system /home/opsys/SPR16/tb+err


cat -n progressFile.txt|head -40

     1	
     2	JobID loaded(DEC):                       1              
     3	Clock value during load(Decimal):        14660317       
     4	------------------------------------------------------
     5	JobID loaded(DEC):                       2              
     6	Clock value during load(Decimal):        14660317       
     7	------------------------------------------------------
     8	JobID loaded(DEC):                       3              
     9	Clock value during load(Decimal):        14660317       
    10	------------------------------------------------------
    11	**WARNING: JOBID(DEC):4 Code:51 Description:MISSING **FIN
    12	------------------------------------------------------
    13	**ERROR: JOBID(DEC):5 Code:6 Description:Invalid Trace flag.
    14	------------------------------------------------------
    15	JobID loaded(DEC):                       6              
    16	Clock value during load(Decimal):        14660317       
    17	------------------------------------------------------
    18	JobID loaded(DEC):                       7              
    19	Clock value during load(Decimal):        14660317       
    20	------------------------------------------------------
    21	JobID loaded(DEC):                       8              
    22	Clock value during load(Decimal):        14660317       
    23	------------------------------------------------------
    24	**WARNING: JOBID(DEC):9 Code:52 Description:Double **DATA
    25	------------------------------------------------------
    26	JobID loaded(DEC):                       9              
    27	Clock value during load(Decimal):        14660317       
    28	------------------------------------------------------
    29	JobID loaded(DEC):                       10             
    30	Clock value during load(Decimal):        14660317       
    31	------------------------------------------------------
    32	JobID loaded(DEC):                       11             
    33	Clock value during load(Decimal):        14660317       
    34	------------------------------------------------------
    35	**WARNING: JOBID(DEC):12 Code:51 Description:MISSING **FIN
    36	------------------------------------------------------
    37	JobID loaded(DEC):                       13             
    38	Clock value during load(Decimal):        14660317       
    39	------------------------------------------------------
    40	JobID loaded(DEC):                       14             

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -3000| head -40

   623	**ERROR: JOBID(DEC):64 Code:5 Description:Illegal Batch Character.
   624	------------------------------------------------------
   625	**ERROR: JOBID(DEC):64 Code:11 Description:Illegal batch format
   626	------------------------------------------------------
   627	JobID loaded(DEC):                       65             
   628	Clock value during load(Decimal):        14665981       
   629	------------------------------------------------------
   630	Completed Execution for jobID(DEC):      26             
   631	Current value of the clock(Decimal):     5962           
   632	clock at load time(hex):                 1698           
   633	Clock at termination time(hex):          174a           
   634	Number of chances at the CPU:            2              
   635	job Output(Hex):
   636	  00000000   00000000   00000000   00000037
   637	Nature of termination:                   Normal         
   638	Runtime(Decimal):                        151            
   639	TurnAroundTime(Decimal):                 178            
   640	Execution Time(Decimal):                 151            
   641	Page Fault Handling Time(Decimal):       360            
   642	------------------------------------------------------
   643	
   644	**WARNING: JOBID(DEC):66 Code:53 Description:MISSING **DATA
   645	------------------------------------------------------
   646	JobID loaded(DEC):                       66             
   647	Clock value during load(Decimal):        14666160       
   648	------------------------------------------------------
   649	**ERROR: JOBID(DEC):23 Code:18 Description:Problem with number conversion.
   650	------------------------------------------------------
   651	Completed Execution for jobID(DEC):      23             
   652	Current value of the clock(Decimal):     6671           
   653	clock at load time(hex):                 bd4            
   654	Clock at termination time(hex):          1a0f           
   655	Number of chances at the CPU:            20             
   656	job Output(Hex):
   657	Nature of termination:                   Arithematic Error
   658	Runtime(Decimal):                        1029           
   659	TurnAroundTime(Decimal):                 3643           
   660	Execution Time(Decimal):                 1029           
   661	Page Fault Handling Time(Decimal):       660            
   662	------------------------------------------------------

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -1400|head -40

  2223	Memory Used:                             208            
  2224	Current Degree of Multiprogramming:      6              
  2225	------------------------------------------------------
  2226	
  2227	Status of the the system:
  2228	Content of subQueue1:                                   
  2229	Content of subQueue2:                                   
  2230	Content of subQueue3:                    24             
  2231	Content of subQueue4:                    91 48 27 20 55 
  2232	Content of Blocked Queue:                               
  2233	ID of current executing Job:             24             
  2234	Memory Free:                             48             
  2235	Memory Used:                             208            
  2236	Current Degree of Multiprogramming:      6              
  2237	------------------------------------------------------
  2238	
  2239	Status of the the system:
  2240	Content of subQueue1:                                   
  2241	Content of subQueue2:                                   
  2242	Content of subQueue3:                    55             
  2243	Content of subQueue4:                    24 91 48 27 20 
  2244	Content of Blocked Queue:                               
  2245	ID of current executing Job:             55             
  2246	Memory Free:                             48             
  2247	Memory Used:                             208            
  2248	Current Degree of Multiprogramming:      6              
  2249	------------------------------------------------------
  2250	
  2251	Status of the the system:
  2252	Content of subQueue1:                                   
  2253	Content of subQueue2:                                   
  2254	Content of subQueue3:                                   
  2255	Content of subQueue4:                    55 24 91 48 27 20 
  2256	Content of Blocked Queue:                               
  2257	ID of current executing Job:             55             
  2258	Memory Free:                             48             
  2259	Memory Used:                             208            
  2260	Current Degree of Multiprogramming:      6              
  2261	------------------------------------------------------
  2262	

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -600|head -40

  3023	Content of subQueue1:                                   
  3024	Content of subQueue2:                    24             
  3025	Content of subQueue3:                                   
  3026	Content of subQueue4:                    91 48 27 55    
  3027	Content of Blocked Queue:                               
  3028	ID of current executing Job:             24             
  3029	Memory Free:                             96             
  3030	Memory Used:                             160            
  3031	Current Degree of Multiprogramming:      5              
  3032	------------------------------------------------------
  3033	
  3034	Status of the the system:
  3035	Content of subQueue1:                                   
  3036	Content of subQueue2:                                   
  3037	Content of subQueue3:                    24             
  3038	Content of subQueue4:                    91 48 27 55    
  3039	Content of Blocked Queue:                               
  3040	ID of current executing Job:             24             
  3041	Memory Free:                             96             
  3042	Memory Used:                             160            
  3043	Current Degree of Multiprogramming:      5              
  3044	------------------------------------------------------
  3045	
  3046	Status of the the system:
  3047	Content of subQueue1:                    91             
  3048	Content of subQueue2:                                   
  3049	Content of subQueue3:                                   
  3050	Content of subQueue4:                    48 27 55 24    
  3051	Content of Blocked Queue:                               
  3052	ID of current executing Job:             91             
  3053	Memory Free:                             96             
  3054	Memory Used:                             160            
  3055	Current Degree of Multiprogramming:      5              
  3056	------------------------------------------------------
  3057	
  3058	Status of the the system:
  3059	Content of subQueue1:                                   
  3060	Content of subQueue2:                                   
  3061	Content of subQueue3:                    91             
  3062	Content of subQueue4:                    48 27 55 24    

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -200|head -40

  3423	Current Degree of Multiprogramming:      1              
  3424	------------------------------------------------------
  3425	
  3426	Status of the the system:
  3427	Content of subQueue1:                                   
  3428	Content of subQueue2:                    27             
  3429	Content of subQueue3:                                   
  3430	Content of subQueue4:                                   
  3431	Content of Blocked Queue:                               
  3432	ID of current executing Job:             27             
  3433	Memory Free:                             224            
  3434	Memory Used:                             32             
  3435	Current Degree of Multiprogramming:      1              
  3436	------------------------------------------------------
  3437	
  3438	Status of the the system:
  3439	Content of subQueue1:                                   
  3440	Content of subQueue2:                                   
  3441	Content of subQueue3:                    27             
  3442	Content of subQueue4:                                   
  3443	Content of Blocked Queue:                               
  3444	ID of current executing Job:             27             
  3445	Memory Free:                             224            
  3446	Memory Used:                             32             
  3447	Current Degree of Multiprogramming:      1              
  3448	------------------------------------------------------
  3449	
  3450	Status of the the system:
  3451	Content of subQueue1:                                   
  3452	Content of subQueue2:                                   
  3453	Content of subQueue3:                                   
  3454	Content of subQueue4:                    27             
  3455	Content of Blocked Queue:                               
  3456	ID of current executing Job:             27             
  3457	Memory Free:                             224            
  3458	Memory Used:                             32             
  3459	Current Degree of Multiprogramming:      1              
  3460	------------------------------------------------------
  3461	
  3462	Status of the the system:

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n progressFile.txt|tail -40

  3583	------------------------------------------------------
  3584	Completed Execution for jobID(DEC):      27             
  3585	Current value of the clock(Decimal):     1224826        
  3586	clock at load time(hex):                 174b           
  3587	Clock at termination time(hex):          12b07a         
  3588	Number of chances at the CPU:            7999           
  3589	job Output(Hex):
  3590	Nature of termination:                   Suspected Infinite Job
  3591	Runtime(Decimal):                        399961         
  3592	TurnAroundTime(Decimal):                 1218863        
  3593	Execution Time(Decimal):                 399961         
  3594	Page Fault Handling Time(Decimal):       360            
  3595	------------------------------------------------------
  3596	
  3597	Report for Batch:
  3598	Current Clock Value:(HEX)                             12b07a         
  3599	Mean user job run time:(DEC)                          45.94          
  3600	Mean user job I/O time:(DEC)                          45.94          
  3601	Mean user job execution time:(DEC)                    8840.68        
  3602	Mean user job time in the System:(DEC)                12126.99       
  3603	Mean user job page fault handling time(DEC):          4961.49        
  3604	Total CPU idle time(HEX):                             8              
  3605	Time lost due to abnormally terminated jobs(HEX):     0              
  3606	Number of jobs that terminated normally(DEC):         84             
  3607	Number of jobs that terminated abnormally(DEC):       17             
  3608	Total Time lost due to Suspected Infinite jobs(HEX):  400001         
  3609	ID's of jobs considered Infinite(DEC):                [27]           
  3610	Total Number of page faults(HEX):                     1877e          
  3611	percentage of Disk Occupied(DEC):                     93             
  3612	Number of holes(DEC):                                 6              
  3613	average size of holes(DEC):                           1              
  3614	average size of holes(DEC):                           1              
  3615	Maximum size of subqueue 1(DEC):                      7              
  3616	Maximum size of subqueue 2:(DEC)                      8              
  3617	Maximum size of subqueue 3:(DEC)                      7              
  3618	Maximum size of subqueue 4:(DEC)                      7              
  3619	Average size of subqueue 1(DEC)                       0.23           
  3620	Average size of subqueue 2(DEC)                       0.27           
  3621	Average size of subqueue 3(DEC)                       0.23           
  3622	Average size of subqueue 4(DEC)                       4.50           

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n MLFBQ.txt|head -60

     1	Clock value(Hex):         1203      
     2	Contents of subqueue1(DEC): [14]      
     3	Contents of subqueue2(DEC): [11, 16]  
     4	Contents of subqueue3(DEC): [2, 3, 9, 6]
     5	Contents of subqueue4(DEC): Empty     
     6	
     7	Clock value(Hex):         2414      
     8	Contents of subqueue1(DEC): Empty     
     9	Contents of subqueue2(DEC): Empty     
    10	Contents of subqueue3(DEC): Empty     
    11	Contents of subqueue4(DEC): [9, 1, 16, 18, 19, 2]
    12	
    13	Clock value(Hex):         3636      
    14	Contents of subqueue1(DEC): Empty     
    15	Contents of subqueue2(DEC): Empty     
    16	Contents of subqueue3(DEC): Empty     
    17	Contents of subqueue4(DEC): [1, 18, 19, 2, 23, 24]
    18	
    19	Clock value(Hex):         4868      
    20	Contents of subqueue1(DEC): Empty     
    21	Contents of subqueue2(DEC): [31]      
    22	Contents of subqueue3(DEC): [23]      
    23	Contents of subqueue4(DEC): [24, 1, 27, 18, 19, 2]
    24	
    25	Clock value(Hex):         6088      
    26	Contents of subqueue1(DEC): Empty     
    27	Contents of subqueue2(DEC): [36]      
    28	Contents of subqueue3(DEC): [19]      
    29	Contents of subqueue4(DEC): [2, 23, 24, 34, 27, 18]
    30	
    31	Clock value(Hex):         7309      
    32	Contents of subqueue1(DEC): Empty     
    33	Contents of subqueue2(DEC): [19]      
    34	Contents of subqueue3(DEC): Empty     
    35	Contents of subqueue4(DEC): [2, 23, 24, 34, 27, 18]
    36	
    37	Clock value(Hex):         8523      
    38	Contents of subqueue1(DEC): [24]      
    39	Contents of subqueue2(DEC): Empty     
    40	Contents of subqueue3(DEC): Empty     
    41	Contents of subqueue4(DEC): [34, 27, 18, 19, 2, 23, 45]
    42	
    43	Clock value(Hex):         9724      
    44	Contents of subqueue1(DEC): [47]      
    45	Contents of subqueue2(DEC): Empty     
    46	Contents of subqueue3(DEC): [19]      
    47	Contents of subqueue4(DEC): [2, 23, 45, 24, 27, 18]
    48	
    49	Clock value(Hex):         10928     
    50	Contents of subqueue1(DEC): Empty     
    51	Contents of subqueue2(DEC): Empty     
    52	Contents of subqueue3(DEC): Empty     
    53	Contents of subqueue4(DEC): [24, 27, 18, 19, 2, 23, 48, 45]
    54	
    55	Clock value(Hex):         12140     
    56	Contents of subqueue1(DEC): Empty     
    57	Contents of subqueue2(DEC): Empty     
    58	Contents of subqueue3(DEC): Empty     
    59	Contents of subqueue4(DEC): [2, 19, 23, 45, 24, 27, 18]
    60	

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n MLFBQ.txt|tail -60

 80791	Clock value(Hex):         1212736   
 80792	Contents of subqueue1(DEC): Empty     
 80793	Contents of subqueue2(DEC): Empty     
 80794	Contents of subqueue3(DEC): [27]      
 80795	Contents of subqueue4(DEC): Empty     
 80796	
 80797	Clock value(Hex):         1213986   
 80798	Contents of subqueue1(DEC): Empty     
 80799	Contents of subqueue2(DEC): Empty     
 80800	Contents of subqueue3(DEC): Empty     
 80801	Contents of subqueue4(DEC): [27]      
 80802	
 80803	Clock value(Hex):         1215236   
 80804	Contents of subqueue1(DEC): [27]      
 80805	Contents of subqueue2(DEC): Empty     
 80806	Contents of subqueue3(DEC): Empty     
 80807	Contents of subqueue4(DEC): Empty     
 80808	
 80809	Clock value(Hex):         1216486   
 80810	Contents of subqueue1(DEC): Empty     
 80811	Contents of subqueue2(DEC): [27]      
 80812	Contents of subqueue3(DEC): Empty     
 80813	Contents of subqueue4(DEC): Empty     
 80814	
 80815	Clock value(Hex):         1217736   
 80816	Contents of subqueue1(DEC): Empty     
 80817	Contents of subqueue2(DEC): Empty     
 80818	Contents of subqueue3(DEC): [27]      
 80819	Contents of subqueue4(DEC): Empty     
 80820	
 80821	Clock value(Hex):         1218986   
 80822	Contents of subqueue1(DEC): Empty     
 80823	Contents of subqueue2(DEC): Empty     
 80824	Contents of subqueue3(DEC): Empty     
 80825	Contents of subqueue4(DEC): [27]      
 80826	
 80827	Clock value(Hex):         1220236   
 80828	Contents of subqueue1(DEC): [27]      
 80829	Contents of subqueue2(DEC): Empty     
 80830	Contents of subqueue3(DEC): Empty     
 80831	Contents of subqueue4(DEC): Empty     
 80832	
 80833	Clock value(Hex):         1221486   
 80834	Contents of subqueue1(DEC): Empty     
 80835	Contents of subqueue2(DEC): [27]      
 80836	Contents of subqueue3(DEC): Empty     
 80837	Contents of subqueue4(DEC): Empty     
 80838	
 80839	Clock value(Hex):         1222736   
 80840	Contents of subqueue1(DEC): Empty     
 80841	Contents of subqueue2(DEC): Empty     
 80842	Contents of subqueue3(DEC): [27]      
 80843	Contents of subqueue4(DEC): Empty     
 80844	
 80845	Clock value(Hex):         1223986   
 80846	Contents of subqueue1(DEC): Empty     
 80847	Contents of subqueue2(DEC): Empty     
 80848	Contents of subqueue3(DEC): Empty     
 80849	Contents of subqueue4(DEC): [27]      
 80850	

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n MLFBQ.txt|tail -1400|head -60

 79451	Contents of subqueue4(DEC): [48, 27, 55, 24]
 79452	
 79453	Clock value(Hex):         937641    
 79454	Contents of subqueue1(DEC): Empty     
 79455	Contents of subqueue2(DEC): [55]      
 79456	Contents of subqueue3(DEC): Empty     
 79457	Contents of subqueue4(DEC): [24, 91, 48, 27]
 79458	
 79459	Clock value(Hex):         938871    
 79460	Contents of subqueue1(DEC): Empty     
 79461	Contents of subqueue2(DEC): [27]      
 79462	Contents of subqueue3(DEC): Empty     
 79463	Contents of subqueue4(DEC): [55, 24, 91, 48]
 79464	
 79465	Clock value(Hex):         940081    
 79466	Contents of subqueue1(DEC): Empty     
 79467	Contents of subqueue2(DEC): Empty     
 79468	Contents of subqueue3(DEC): Empty     
 79469	Contents of subqueue4(DEC): [48, 27, 55, 24, 91]
 79470	
 79471	Clock value(Hex):         941291    
 79472	Contents of subqueue1(DEC): [24]      
 79473	Contents of subqueue2(DEC): Empty     
 79474	Contents of subqueue3(DEC): Empty     
 79475	Contents of subqueue4(DEC): [91, 48, 27, 55]
 79476	
 79477	Clock value(Hex):         942531    
 79478	Contents of subqueue1(DEC): Empty     
 79479	Contents of subqueue2(DEC): Empty     
 79480	Contents of subqueue3(DEC): Empty     
 79481	Contents of subqueue4(DEC): [55, 24, 91, 48, 27]
 79482	
 79483	Clock value(Hex):         943742    
 79484	Contents of subqueue1(DEC): Empty     
 79485	Contents of subqueue2(DEC): Empty     
 79486	Contents of subqueue3(DEC): [48]      
 79487	Contents of subqueue4(DEC): [27, 55, 24, 91]
 79488	
 79489	Clock value(Hex):         944970    
 79490	Contents of subqueue1(DEC): [91]      
 79491	Contents of subqueue2(DEC): Empty     
 79492	Contents of subqueue3(DEC): Empty     
 79493	Contents of subqueue4(DEC): [48, 27, 55, 24]
 79494	
 79495	Clock value(Hex):         946182    
 79496	Contents of subqueue1(DEC): Empty     
 79497	Contents of subqueue2(DEC): Empty     
 79498	Contents of subqueue3(DEC): [55]      
 79499	Contents of subqueue4(DEC): [24, 91, 48, 27]
 79500	
 79501	Clock value(Hex):         947383    
 79502	Contents of subqueue1(DEC): [27]      
 79503	Contents of subqueue2(DEC): Empty     
 79504	Contents of subqueue3(DEC): Empty     
 79505	Contents of subqueue4(DEC): [55, 24, 91, 48]
 79506	
 79507	Clock value(Hex):         948593    
 79508	Contents of subqueue1(DEC): Empty     
 79509	Contents of subqueue2(DEC): Empty     
 79510	Contents of subqueue3(DEC): [91]      

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n 3x4Matrix.txt

     1	      35    40    45    50   
     2	3     40060 52997 45909 31588
     3	4     58393 52995 36639 31576
     4	5     58392 52994 36638 31576

ls

3x4Matrix.txt		    CPU.java	      ErrorHandler.class  Memory.class	PCB.java	  Scheduler.java  trace-JobID-100.txt  trace-JobID-65.txt  typescript
ArthematicOperations.class  CPU$opCode.class  ErrorHandler.java   Memory.java	Procedure.sh	  SWE_report.txt  trace-JobID-10.txt   trace-JobID-75.txt
CPU$1.class		    Disk.class	      Loader.class	  MLFBQ.txt	progressFile.txt  system.class	  trace-JobID-39.txt   trace-JobID-77.txt
CPU.class		    Disk.java	      Loader.java	  PCB.class	Scheduler.class   system.java	  trace-JobID-5.txt    trace-JobID-98.txt

cat -n SWE_report.txt

     1	Software engineering issues
     2	==========================================
     3	For Phase III the challenge faced was in managing the context with respect to looping the 
     4	test batch 12 times where I had to selectively manage certain values while resetting the 
     5	state of the other values which had to be done using the best practices without anti-patterns.
     6	One of the biggest challenge with the project overall was the debugging. This is due 
     7	the complexity of the project.For example an error in Indexing caused my previous 
     8	process to write in the wrong memory locations which impacted the execution of 
     9	current process. The tradition debugging using IDE i.e.., using breakpoints and 
    10	step into/over/out functions were not useful as I would had to go back thousands of 
    11	execution steps backward sometimes to find the root cause. Whenever an issue occurred
    12	the progress file was taken as an aid for debugging which made the process much more simple.
    13	
    14	Another challenge faced during the designing was breaking down stage 2 into steps and 
    15	following a modular approach in development. First disk was developed and tested then 
    16	the memory manager was loaded and the scheduling responsibilities were tested. Finally the
    17	CPU underwent minor changes(for reading and writing) to complete the changes.
    18	
    19	The status of the operating system which was decided to be generated at an interval of 
    20	2500 CPU clock cycles as it seemed a perfect balance between not generating a large trace
    21	file with unnecessary data and not printing enough status to miss out on what is going on 
    22	in the CPU.
    23	
    24	General approach to the problem
    25	===========================================
    26	I made changes incrementally according to the requirement and tested
    27	as I did in Phase II.I used the test cases that I did in Phase I to 
    28	make sure that the changes does'nt break anything. I constantly backed 
    29	up my files so that I can go back to the previous version whenever 
    30	something breaks.
    31	
    32	List of the utilities being used
    33	===========================================
    34	- Debugger: Java debugger
    35	- Integrated build tool: Eclipse Mars
    36	- grep commands for bulk complexities
    37	
    38	Bulk complexities of simulation program
    39	===========================================
    40	        Metric			Value
    41	-------------------------------	--------
    42	    Total Lines	   	         3755
    43	    	-Comment Lines		 443
    44	    	-Code Lines          	 3169    
    45	    	-Blank Lines		 161
    46	    	-declarations		 377
    47	    Number of decisions		 322
    48	    Number of functions		  74
    49	    Number of classes		   9
    50	
    51	Approximate break-down of the time spent in the design, 
    52	coding, and testing
    53	=============================================
    54	Task                Time spent
    55	----------------------------------------
    56	Conceptualization           2 day
    57	Requirements analysis       1 day
    58	Detailed specification of 
    59	software requirements       2 days
    60	Design  Software Design     1 day
    61	Implementation Programming  8 days
    62	Testing and bug fixing      2 days
    63	Deployment                  2 hour
    64	----------------------------------------
    65	Total                       17 days (approx.)
    66	-----------------------------------------
    67	Simulation portability
    68	==============================================
    69	This simulation was developed using Java language. Java program is platform 
    70	independent because it needs java runtime to execute java byte code. Java runtime 
    71	can be installed in many systems including Windows x64/x86, Solaris SPARC x64/x86, 
    72	Mac OS X x64, Linux x64/x86. Other platforms can use java runtime from open source 
    73	project named OpenJDK which developer can build java runtime from source. 
    74	
    75	Implementation language
    76	==============================================
    77	I chose Java because it is  platform independent, and it 
    78	also has a rich built in libraries. For statically typed language,
    79	the IDE can support full re-factoring that is a very convenient feature. 
    80	IDE of my choice is Eclipse IDE Mars Release (4.5.1)
bash-4.3$ exit
exit

Script done on Fri 29 Apr 2016 03:43:31 AM CDT
